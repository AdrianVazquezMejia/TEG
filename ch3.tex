En esta capitulo se describirá el diseño de la red y los detalles de software y hardware de los nodos.

\section{DISEÑO DE LA RED MALLADA}

Tomando en cuenta la investigaciones realizadas se encontró que en el campo de las redes WiFi malladas no existe un protocolo de aplicación definido, en su lugar, las redes son ajustadas a las necesidades específicas del campo en cual se vaya a implementar, esto trae como consecuencia que las especificaciones se concentren en el máximo rendimiento en las áreas críticas del problema. 

Dentro de los funcionamiento descritos anteriormente, se tiene que \\ref{primera} se concentra en el algoritmo de optimización de la topología de la red, sin tomar en consideración el hardware de implementación. Por otro lado \ref{segunda}, provee una aproximación más realista, proveyendo las especificaciones del hardware, sin embargo, no hay justificación para el enrutamiento usado y las medidas de rendimiento aplicadas no son de interés para el área industrial. Por último, se tiene que la ESP-MESH parecía  brindar extensibilidad y rápido desarrollo, no obstante, posee la desventaja de la necesidad de un enrutador WiFi  para la formación, que brinde las direcciones IP a la red mallada, lo que deriva en un centralización, pues si el router falla, la red perece. 

Por lo tanto, es conveniente poseer una arquitectura especifica de la red mallada para el funcionamiento dentro de una red Modbus. Así se puede adaptar y configurar de manera más óptima y confiable para las funciones y características del protocolo Modbus.

Para la creación de red inalámbricas WiFi usando el microcontrolador ESP-32, \emph{Espressif} a través del \emph{ESP-IDF} (Espacio de trabajo para desarrollo de Internet de las cosas) provee de dos librerías: la ya mencionada ESP-IDF y ESP-NOW.  La librería ESP-NOW fue ideada para comunicaciones punto a punto en esquemas maestro/esclavo, no para creaciones de redes multi-salto, sin embargo, posee la expansibilidad de manipular el direccionamiento de los datos, brindado la potencialidad de crear redes de diversas arquitectura.

\subsection{ESP-NOW}
\espn  es un tipo de protocolo de comunicación WiFi definido por \emph{Espressif Systems}. En la comunicación \espn los datos de aplicación son encapsulados en una trama específica por el proveedor y es transmitida de un dispositivo \wf a otro. Para proteger la trama de acción por seguridad se usa CTR con el protocolo CBC-MAC (CCMP). \espn es ampliamente usada en luces inteligente, control remoto y sensores.

\espn permite desarrollar redes según la arquitectura definida en la capa de aplicación, por lo que es ideal para la implementación de nuevas topologías y procesos de red. Además, debido a que la comunicación es punto a punto, la red no se centraliza. Así mismo, posee una capacidad de carga aceptable para la transmisión de tramas Modbus, por lo que fue la librería utilizada para el diseño e implementación de la red.


\subsection{Requerimientos de diseño} 
 
 Principalmente debe ser una red confiable, estable, y eficaz; aprovechando las principales características de las redes malladas, como saltos múltiples y descentralización. La nodos deben soportar al menos la configuración básica descrita por Modbus para linea serial garantizando la interoperatividad con otros equipos Modbus.
 Los nodos deben  ser configurables, pudiendo ajustar las rutas de la red y la tasa de baudios de la interfaz serial, para así, obtener una red extensible. 


\subsection{Diseño Básico de la red}
 Un nodo es una estación de comunicación con una dirección MAC bajo el estándar 802.11 y  una implementación de capa física (En este caso el \mcu) para la comunicación bajo este protocolo, además, constituye la entidad básica de la red.  La red más elemental, llamada  conjunto de servicios básicos (BSS), puede  ser formada por dos nodos. Para que otros nodos se unan, los integrantes del BSS provee de servicios a través de un sistema de distribución (DS) que permiten la comunicación con con dispositivos fuera del BSS para su integración.  Los enlaces se forman a partir del nodo que genere la trama (salto inicial) e indique el nodo siguiente (nodos intermedios) hasta llegar al nodo final (salto final). En este proceso de formación los nodos involucrados en el proceso forman una BSS que permanece establecido. 
 
\subsubsection{Estructura de la trama}

Actualmente, el estándar 802.11 clasifica las tramas como tramas datos, tramas de control, o tramas gestión. La trama de datos transmite la información en las capas más altas. Las tramas de control son usadas para agradecimientos y reservaciones. Finalmente, los dispositivos usan las tramas de gestión para configurar, organizar y mantener el enlace local.

\espn usa una trama de acción específica de proveedor para transmitir datos. La tasa de transmisión por defecto es de 1 Mbps y formato de la trama es como se muestra en la tabla \ref{Tabla: espn}.
\begin{table}[H]
\resizebox{15cm}{!}{
\begin{tabular}{|c|c|c|c|c|c|}
\hline 
Dirección MAC & Código de categoría & Identificador de organización & Valores aleatorios & Contenido de provedor & FCS \\ 
\hline 
24 bytes & 1 byte & 3 bytes & 4 bytes & 7-255 bytes & 4 bytes \\ 
\hline 
\end{tabular}\label{Tabla: espn}
}
\caption{Trama de acción  \espn}
\end{table}

\begin{enumerate}
\item Código de categoría:  es establecido en 127 para indicar la trama específica de proveedor.
\item Identificador de organización:  contiene un identificador único (0x18fe34), los cuales son las primeros tres bytes de la MAC aplicada por \emph{Espressif}.
\item Valores aleatorios: son usador para prevenir ataques de retransmisión.
\item Contenido de proveedor: Contenido de específico de proveedor, contiene datos adicionales.
\item FCS: Chequeo de errores.
\end{enumerate}
 
\begin{table}[H]
\resizebox{15cm}{!}{
\begin{tabular}{|c|c|c|c|c|c|}
\hline 
ID de elemento& Longitud & ID de organización & Tipo & Versión & Cuerpo\\ 
\hline 
1 byte & 1 byte & 3 bytes & 1 byte & 1  bytes & 9 - 250 bytes \\ 
\hline 
\end{tabular} 
}
\caption{Contenido de específico de proveedor}\label{Tabla: body}
\end{table}
\begin{enumerate}
\item  ID de elemento: Es establecido en 221, para indicar elemento de específico de proveedor.
\item Longitud: Es la longitud total de ID de organización, tipo, version  y cuerpo.
\item Tipo: Es establecido en 4, para indicar \espn.
\item Versión: Versión de \espn.
\item Cuerpo: El  cuerpo contiene los datas \espn.
\end{enumerate}

En el protocolo \espn la cabecera MAC varia respecto a las convencionales, el primer campo es dedicado a la dirección destino, la segunda la dirección de origen y la tercera es usada para establecer la dirección broadcast (0xFF:0xFF:0xFF:0xFF:0xFF:0xFF).En las tramas \espn los bits de control de tramas \textit{FromDS} y \textit{ToDS} son ambos cero. 

Los campos de gestión que indican las direcciones MAC son usados para mantener la red, y el servicio de distribución para ingresar nuevos nodos, se logra a partir de la dirección broadcast. 

Los campos de cuerpo de la trama también son usados para manejar la comunicación en la red mallada en la capa de aplicación, cada nodo posee una lógica dependiente de la tramas recibidas. La estructura de datos del cuerpo toma la forma definida en la tabla \ref{Estructura}.

\begin{table}{H}
\centering
\begin{tabular}{|c|c|}
\hline 
type & Broadcast o unicast \\ 
\hline 
state & Indica si se han recibido datos broadcast  \\ 
\hline 
seq\_num & Numero de secuencia \\ 
\hline 
crc & Crc de los datos \\ 
\hline 
dir & Dirección desde o hacia el maestro \\ 
\hline 
Nodeid & Identificador del nodo \\ 
\hline 
payload & Carga  \\ 
\hline 
data\_len & Longitud de los datos \\ 
\hline 
\end{tabular}
\caption{Estructura de datos envidada en el cuerpo de la trama \espn}\label{Estructura}
\end{table}

\subsubsection{Gestión y formación mallada}

Una señal broadcast proveniente de un nodo se usa para detectar la red y obtener información sobre sus configuración. Los nodos se detectan entre sí en un escaneo activo. La trama de escaneo se identifica debido a que es generada mediante broadcast. La información recibida posee tres campos claves: información del identificador del nodo, si se ha recibido o no información broadcast antes del nodo por el que se está buscando y un campo adicional Modbus. El escaneo se realiza cuando un nodo no posee la dirección MAC de otro nodo en su tabla de enrutamiento y se requiere enviar datos a este. La fuente de datos posee el esclavo Modbus destino, lo que es usado para registrar solo aquellos nodos que tengan relación con el esclavo particular.  Una vez los nodos se han registrado unos a otros la relación permanece, incluso si algún nodo es apagado, una vez sea se reinicie la red permite una rápida reconexión.

Los nodos solo usan un transceptor simple, por lo tanto, la red mallada opera en un solo canal de frecuencia WiFi. Esto indica que se puede colocar una red en cada canal WiFi en un mismo espacio físico, sin llegar a tener conflictos de canal. 

\subsubsection{Seguridad}
Cada nodo \espn usa el método CCMP, el cual está descrito en el estándar 802.11- 2012, para proteger la trama de acción específica del proveedor. Esto junto con un algoritmo de cifrado mutuo, los nodos emparejados usan una llave maestra primaria (PMK) que es usada para cifrar las  llaves de cifrado locales (LMK) con el algoritmo AES-128. Este método de permite la autenticación entre dos nodos emparejados. Debido a que es un cifrado por emparejamiento, cada vínculo es independientemente asegurado, como consecuencia, \espn no provee cifrado fin-a-fin. 

El cifrado para comunicación broadcast no esta soportado. Las llaves locales(LMK) son usadas por el método CCMP y cada nodo puede contener hasta seis llaves diferentes, si la llave local no se establece la trama de acción permanece sin cifrado. 
%agregar esquema 

\subsubsection{Selección de rutas}

Las rutas no son determinadas por la red, si no por el usuario que la implemente. Además, son estáticas y no se reasignan automáticamente, estas rutas son asignadas a una tabla unidimensional, con los identificadores de los nodos destinos. El enrutamiento está estrechamente relacionado con los esclavo Modbus, y están representados por las posiciones en la tabla de enrutamiento.

La red no propaga información de las rutas, por lo que cada nodo solo conoce la ruta para una salto en cualquier sentido. Sin embargo, es posible solicitar y configurar las rutas de los nodos inalabricamente.

La tabla de enrutamiento posee 256 casillas (una para cada esclavo Modbus), donde la posición está asociada al esclavo Modbus y el valor en la casilla se relaciona con la ubicación de dicho esclavo. Cabe resaltar que el identificador al que se refiere la tabla de enrutamiento como destino no es la localización del esclavo en la red. En la figura En la figura \ref{Fig  2: Tabla de enrutamiento} se ilustra el la arquitectura e interpretación de la tabla de enrutamiento asociada al nodo 255.
 

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{rt.eps}\label{Fig  2: Tabla de enrutamiento}
\caption{Ilustración de la estructuras de la tabla de enrutamiento}
\end{figure}

Existe otra tabla de enrutamiento para las respuestas, de manera tal que las rutas sean bidireccionales y únicas. La tabla de respuesta es configurada y mantenida automaticamente por cada nodo. Cuando se reciben solicitudes Modbus, se guarda el identificador del nodo del cual provino dicha información, y dicho identificador se usa para enrutar la trama respuesta.

 Un esquema del funcionamiento se puede apreciar en las figuras \ref{Fig 1: ULM enrutamiento} y \ref{Fig 1: ULM serial} .
 
 \begin{figure}[H]
\centering
\includegraphics[scale=0.4]{UML2.eps}\label{Fig 1: ULM enrutamiento}
\caption{Diagrama de flujo del funcionamiento general de un nodo de la red recibiendo información WiFi}
\end{figure}

 \begin{figure}[H]
\centering
\includegraphics[scale=0.4]{UMLSerial.eps}\label{Fig 1: ULM serial}
\caption{Diagrama de flujo del funcionamiento general de un nodo de la red recibiendo información serial}
\end{figure}

\subsubsection{Características Modbus de los nodos}
 
Los nodos de la red son esclavos adicionales de la red Modbus, con direcciones reservadas para ellos desde el identificador(101). El modo de operación Modbus en los nodos permite que se puedan obtener  y configurar parámetros de la red, como la tabla de enrutamiento de los nodos. Además el proceso es realizado mediante un protocolo estandarizado y que esta relacionado con la red.

El funcionamiento como esclavo Modbus de los nodos es permanente, incluso cuando ya se ha implementado la red con esclavos Modbus seriales, permitiendo actualización de parámetro de la red en cualquier momento. 

Los nodos poseen un diagnóstico visual que indica cuando se ha recibido o enviado correctamente una trama  serial o inalambricamente. Dicho diagnóstico de basa en un LED que emite un pulso. Además, otro diagnóstico visual para indicar que se ha encendido el equipo, del mismo tipo se encuentra en la tarjeta de alimentación. No hay diagnostico visual para errores de comunicación.%observe hardaware para mas detalle.

Los registros disponibles para acceso son los registros de retención desde la dirección cero hasta la 512, y también las diez primeras bobinas. Para las bobinas solo es soportada la función de escribir una bobina simple. La tabla \ref{Tabla 1: Espec HR} describe la asignación de los registros.


 
\begin{table}[H]
\centering
\begin{tabular}{llr}
 \toprule
Dirección & Tipo de registro & Descripción  \\
\midrule
01 & Registros de retención & Identificador \\
02 & Registros de retención    &  Tasa de baudios  \\
256-512 & Registros de retención  & Tabla de enrutamiento\\
0 & Bobina &Reinicio \\
1 & Bobina &Guardar valores Modbus para ejecución\\
2 & Bobina &Guardar valores Modbus en  la memoria Flash\\
\bottomrule
\end{tabular}
\caption{Tablas primarias de los modelos de datos Modbus}\label{Tabla 1: Espec HR}
\end{table}

La tabla \ref{Tabla 1: Espec Modbus} posee una descripción de la parámetros Modbus.
 \begin{table}[H]
\centering
\begin{tabular}{llr}
 \toprule
Dirección & Por defecto & Opciones \\
\midrule
ID Modbus & 255 & 101 a 255 \\
Tasa de baudios serial & 19200   &  300 a 115200 \\
Tabla enrutamiento & Nula &Valores válidos de ID Modbus \\
Modo & RTU & Ninguna \\
Paridad & Ninguna & Ninguna \\
Bits de parada & 1 & Ninguna \\
\bottomrule
\end{tabular}
\caption{Parámtros Modbus}\label{Tabla 1: Espec Modbus}
\end{table}

Cabe resaltar que estos nodos pueden ser interrogados tanto serial como inalambricamente, es decir, con la red ya instalada. Las funciones no usadas proveerán la excepción Modbus "Función ilegal". 

\subsubsection{El hardware}\label{hardware}

El hardware del nodo se puede dividir en tres bloques: el microcontrolador, la alimentación y la interfaz serial. Esto de puede ilustrar en el esquema de la figura \ref{Fig  4: Diagrama de bloques}.
 \begin{figure}[H]
\centering
\includegraphics[scale=0.5]{diagrama.eps}\label{Fig  4: Diagrama de bloques}
\caption{Diagrama de bloques para el hardware del nodo}
\end{figure}


\paragraph{Microcontrolador}

Para la aplicación se usó el encapsulado  ESP-WROOM-32, debido a disponibilidad y encapsulado con escudo WiFi . Se debe tener en cuenta que se dejaron disponibles los pines del UART cero para la descarga del software, además de dos pines adicionales para inducir el estado de programación, los cuales son el pin \textit{EN} y el pin de propósito general cero.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{ESP-WROOM-32.jpg}\label{Fig  x: ESP-WROOM-32}
\caption{Encapsulado ESP-WROOM-32 del ESP32}
\end{figure}
 
\paragraph{Alimentación}
La alimentación del microcontrolador es de 3,3 V y además los equipos Modbus especifican un rango de tensión de funcionamiento entre 5 V y 25 V. Por lo tanto se escogió el regulador conmutado LM2596S que brinda estas características y además existe una tarjeta pre-fabricada para rápida implementación. La figura \ref{dcdc.jpg} muestra la forma de dicha tarjeta. Además posee un LED testigo de su encendido, que es usado como señal de diagnóstico Modbus.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{dcdc.jpg}\label{dcdc}
\caption{Tarjeta con regulador lineal para alimentación}
\end{figure}
 %Otras especifiaciones
 
 Las características eléctricas son presentadas en la tabla \ref{Espec dcdc}
 \begin{table}
 \centering
 \begin{tabular}{|c|c|}
 \hline 
 Voltaje de entrada & 4 V - 35 V \\ 
 \hline 
 Voltajes de salida & 1,23 V 30 V \\ 
 \hline 
 Corriente de entrada &  3 A (Máxima) \\ 
 \hline 
 Eficiencia de conversión & 92\% (Máxima) \\ 
 \hline 
 Frecuencia de conmutación & 150 kHz \\ 
 \hline 
 Ripple de salida &  30 mA (Máximo) \\ 
 \hline 
 \end{tabular} 
 \caption{Especificaciones de la fuente de alimentación}\label{dcdc}
 \end{table}

\paragraph{Interfaz serial}

Modbus en sus clases básica dicta que los equipos Modbus  seriales tienen que poseer la interfaz eléctrica RS-485 de dos cables de acuerdo con el estándar EIA/TIA-485. Por esto se seleccionó para la implementación en el nodo, asegurando la máxima compatibilidad. 

El chip MAX3485 de \emph{Maxim Integrated} provee de las características antes descritas y admite tensión de alimentación de 3,3 V, lo cual hace que se posea un solo nivel de tensión para la alimentación del nodo.

Este chip soporta hasta 32 dispositivos, pero teniendo en cuenta que el uso de nodos distribuye la carga de los esclavos, la utilización de repetidores se vería disminuida.

La topología RS-485 Modbus sin repetidor posee cables truncados en un par trenzado, sobre los cuales los dispositivos están conectados bien sea directamente o a través de cables de derivación. Los cables truncados también llamado bus, cuya longitud depende de la tasa de baudios, los parámetros del cable y  la carga de dispositivos, para 9600 baudios y un cable calibre de 26 AWG, la máxima longitud es de 1000 m. 

Las derivaciones no deben estar a más de 20 m. En caso del uso de una derivación de puertos múltiples con $n$ derivaciones, cada una tiene que respetar una distancia máxima de 40 m dividida por $n$.

El circuito común de cada bus debe estar conectado a tierra, preferiblemente a un solo punto para todo el bus.  Esto no aplica para la red, pues evidentemente la comunicación inalámbrica brinda aislamiento galvánico.

Para minimizar las reflexiones del final del cable RS-485 se requiere colocar un terminador de linea cerca del final de cada punto del bus (Resistencia de 150 $\Omega$ y 0,5 W). No se deben colocar más de dos terminadores de linea en el bus, ni colocar terminadores de linea en los cable de derivación.

Si el sistema requiere polarización esta de debe implementar en cada bus serial del sistema, los nodos inalámbricos no requieren polarización.

La interfaz mecánica consta de de Bloques terminales, la identificación  RS-485 se encuentra en la el circuito impreso.

Los cables de la linea serial deben estar blindados, deben formar una par balanceado y deben poseer un tercer cable (Común).  Estos deben posee el calibre suficiente para permitir la máxima distancia. Un calibre de 24 AWG es siempre suficiente. Además, preferiblemente se debe seleccionar cables con una impedancia características mayor a 100 $\Omega$, especialmente para tasas de Baudios mayores a 19200.

\section{Detalle del Diseño}
\subsection{Programación del ESP-32}
El fabricante del \mcu \textit{Espressif Systems} especifica  los recursos básicos de hardware y software relacionados con el desarrollo de aplicaciones que usen la serie de hardware del ESP32.

El hardware necesario son: una tarjeta de desarrollo con un ESP32, un cable USB y computador que posea Windows, Linux o MACOS. Para el desarrollo del programa se usaron tarjetas de desarrollo ESP32-DevKitC V1 y un computador con sistema operativo Ubuntu 18.04 LTS.

En cuanto al software se puede representar por capas:
\begin{enumerate}
\item Un \textbf{Toolchain} para compilar el código para el ESP32: Xtensa-ELF 1.22.0.
\item \textbf{Herramientas de construcción}  para construir toda la aplicación para el microcontrolador, en este caso se usó  \textit{GNU Make} 4.1.
\item ESP-IDF  que contiene esencialmente las librerias y los scripts para operar con el \textbf{Toolchain}, versión 4.0.
\item \textbf{Editor de texto } para escribir los programas en C, en este caso \textit{Eclipse IDE} 2019-12.
\end{enumerate}


 \begin{figure}[H]
\centering
\includegraphics[scale=0.5]{toolchain.png}\label{Fig  3: Desarrollo de aplicaciones}
\caption{Ilustración del combo para el desarrollo de aplicaciones en el ESP32 }
\end{figure}

Los detalles de la instalación de cada uno de estas herramientas se llevo a cabo siguiendo la metodología propuesta por \textit{Espressif } en el su pagina web \url{https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/index.html}.


\subsubsection{El sistema operativo en tiempo real}

El microcontrolador ESP32 está diseñado para correr un sistema operativo en tiempo real(RTOS) basado en el  \textit{FreeRTOS} desarrollado por \textit{Amazon}.Un sistema operativo de tiempo real es una herramienta eficiente para dispositivos con poca capacidad de procesamiento. Es decir, aquellos dispositivos que no cuentan con una variedad de núcleos o kernels. RTOS trata de implementar en estos microsistemas una similud de comportamiento de múltiples unidades de procesamiento aún estando contenidas en un solo núcleo. Lo cuál es una ventajaimportante para la implementación de sistemas de mayor complejidad de código.La lógica funcional del método de programación RTOS es mediante establecimiento de tareas e interrupciones controladas por órden de prioridad y por el timer principal del sistema. Además, soporta las casi las misma características desde el punto de vista de  creación y manejo de tareas, así como de las demás herramientas que ofrece un sistema operativo en tiempo real. 

Dicho sistema operativo permite que se creen y desarrollen programas en lenguaje ANSI C, implementado las librerías para el manejo del microcontrolador proveídas por ESP-IDF de \textit{espressif}. Por lo tanto, el desarrollo del programa se basó en la creación de tareas y la comunicación entre ellas basada en colas. Se crearon tareas dos tareas para el manejo de los datos inalámbricos, una para la recepción de datos mediante el UART  y otras tareas con funciones de monitores fueron añadidas.

\subsection{ Programa de la red diseñada que soporte la transmisión del protocolo Modbus}
El rol de cada nodo en la red es determinado por la secuencia de estados durante operación, por lo que el programa es idéntico para todos los microcontroladores, incluido el que posee conectado el maestro. Cualquier nodo puede enviar datos, incluso aquellos que posee esclavos Modbus en su interfaz serial.
  
  
  En primer lugar se definen el la aplicación principal (app main) las funciones que se llevaran a cabo al iniciar el microcontrolador. La inicialización de la flash, el módulo WiFi, el UART y la creación de tareas toma lugar en esta parte. Esta sección se ejecuta solo una vez. 
\subsubsection{Librerías}
 En el programa se incluyen la librerías estándar de C  <stdlib.h> , <time.h>, <string.h>, y  <assert.h>, para el uso y manejo de las principales funciones de C. Luego tenemos que freertos/file.h provee del las funciones necesarias parar la ejecución y uso del sistema operativo en tiempo real.  Restando las inclusiones asociadas al ESP-IDF para el uso de las librerías de funciones del microcontrolador.
 
 La librería nvs\_flash.h, habilita para el uso de la funciones de acceso a la flash, necesarias para guardar y cargar la configuración a los nodos.
 
 Las inclusiones  esp\_log.h, esp\_system.h, esp32/rom/ets\_sys.h, esp32/rom/ets\_sys.h y esp32/rom/crc.h permiten el uso del sistema del ESP-32 para el acceso a estado del sistema como estado de la pila, reinicio, etc.
 
 Finalmente, para el uso de las funciones para la construcción de la red mallada son necesarias las inclusiones siguientes: tcpip\_adapter.h, esp\_wifi.h, esp\_now.h, espdefine.h
 
\subsubsection{Inicialización}
La rutina para las tareas de la red mallada comienzan con la inicialización del periferico WiFi y funciones ESP-NOW mediante las funciones \emph{wifi\_init()} y \emph{espnow\_init()} respectivamente.
  
Con la función  \emph{wifi\_init()} se inicializan el adaptador TCP/IP, el manejador de eventos WiFi y se carga la confiuración, en este caso como sigue:
\begin{enumerate}
\item Modo de punto de acceso
\item Canal cero
\item Modo de largo alcance
\item Soporte de los protocolos 802.11b,802.11g y 802.11n.
\end{enumerate}

Luego tenemos la función  \emph{espnow\_init()} que prepara las variables iniciales, crea las colas de recepción y envío, registra las funciones de \textit{callback} de recepción y envío, establece las claves de encriptación, registra los nodos y crea la tareas.

\subsubsection{Creación de colas (\emph{Queue})}
 
 En la incialización se crean tres colas 
 \begin{enumerate}
 \item \emph{espnow\_queue} que se usa para transmitir los datos de las funciones de \textit{callback}  a las tareas que manejan la red. 

 \item \emph{espnow\_Squeue} se usa para la transmisión de los datos desde la tarea asociada al UART.
 
  \item \emph{espnow\_Rqueue} se usa para transmitir los datos hacia la tarea que envía información inalambricamente.
 \end{enumerate}
 \subsubsection{Las funciones de callback}
 
 Estas son funciones escritas por el programador que son llamadas dentro del pila WiFi automáticamente, y permite que la información del proceso de enviar y recibir se pueda manejar desde otras funciones o tareas más complejas. El fabricante recomienda que se mantenan cortas dichas funciones, que en su lugar se use una cola y se maneje la información desde otras funciones.
 
 Estas funciones son activadas cuando se envía o recibe información mediante ESP-NOW. La de envío provee información de la MAC y el estado (envío exitoso o no) y la de recepción la MAC, los datos y la longitud de la trama.
 
 En estas funciones basicamente se pasan los datos a la aplicación principal junto con una variable que ayuda a conocer el estado del sistema del tipo \emph{espnow\_event}.
 
 \subsubsection{Registro de puntos}
 
 En la librería \emph{espnow} existen unos entes llamados \emph{Peers} (Puntos), los cuales conservan la información de cada dispositivo con el que se pueda interactuar. Si un peer no está registrado, es imposible enviar información a el o recibirla. Hay un peer virtual para enviar información brodacast cuya característica es la dirección MAC, la cual es la mayor posible (FF:FF:FF:FF:FF:FF).
 
 Los campos de cada puntos son los descritos en la tabla \ref{Tabla 2: información de peers}
 
\begin{table}[H]
\centering
\begin{tabular}{lr}
 \toprule
Parámetro & Descripción  \\
\midrule
peer address &  Dirección MAC \\
lmk & Clave maestra local que es usada para cifrar los datos  \\
channel & Canal WiFi\\
ifidx & Interface que usa el WiFi para enviar y recibir datos \\
encrypt & Habilitador de cifrado \\
*priv & Datos privados de la librería  \\
\bottomrule
\end{tabular}
\caption{Tablas primarias de los modelos de datos Modbus}\label{Tabla 2: información de peers}
\end{table}

La información de los puntos es guardada mediante la función \emph{esp\_now\_add\_peer()}.
\subsubsection{Estructuras de datos relevantes}

Se crearon ciertas estructuras usando el lenguaje C, para manejar los datos con mayor facilidad y orden. 

\begin{enumerate}
\item \emph{espnow\_send\_param\_t}: esta estructura esta diseñada para contener los datos en la transmisión de los datos. Indica si la trama es unicast o bradcast. La longitud de los datos, los datos a enviar, el número de secuencia, el estado de la transmisión, etc.

\item \emph{espnow\_event\_t} : es la estrutura usada para manejar los estados nodo. Permite que posea información relacionada con los datos trasmitidos, la dirección y el estado. 


\item \emph{esp\_uart\_data\_t}: Esta estructura de datos se creó para comunicar las tareas del uart y las de ESP-NOW, no solo posee los datos recibidos si no también el sentido en la red de estos. 
\end{enumerate}



\subsection{Tarea esp\_now\_manage\_task}

Es la tarea principal del sistema de comunicación inalámbrica, es administrada por la cola \emph{espnow\_queue}. Cabe mencionar que las colar permiten que la tarea se ejecute solo si se recibió un dato en ella, lo cual ayuda mantener la eficiencia del procesador.

En esta tarea se verifica si se estaba enviando o recibiendo datos. Y exiten ciertos procesos que se ejecutan en cada caso, considerando si es broadcast o unicast.

La cola se habilita por las funciones de \emph{callback} y por la tarea del UART.

A continuación se presenta pseudocódigo de la ejecución de la tarea.\\
%%%Pseudo codigo goes here.
\begin{algorithm}[H]
 \KwData{ADU MODBUS, EVENT\_DATA}
 \KwResult{ADU MODBUS ADMINISTRADA }
 Inicialización\;
 \While{Se recibe algo en la cola}{
 	\Switch{Event ID}{
		\Case{Desde enviar}{ 
			\Switch{Origen}{
				\Case{De la función de Callback}{
					\eIf{desMAC == broadMAC}{
						\If{contador ==0}{break}
							contador--;\\
							Enviar broadcast;\\
					}{
					\eIf{estado de envío == exito \emph{or} intentsos == 5}{break;}{
						Intentos ++\\
						Enviar a la cola espnow\_Squeue;\\
					}						
					}
				}
				\Case {De la tarea UART}{
					Enviar a la cola espnow\_Squeue;\\
				}			
				
		} 
		\Case{Desde recibir}{
			\eIf{Broadcast}{
				\If{Nodo no está registrado}{
					Registrar nodo;\\
				}
			}{\eIf{Unicast}{
				\emph{UnicastAlgo();}
			}
			{Error}				
			}			
			}
		}
 	}
 }

 \caption{Algoritmo tarea esp\_now\_manage\_task}\label{Algo1}
\end{algorithm}[H]
\begin{algorithm}
 \KwData{ADU MODBUS, EVENT\_DATA}
 \KwResult{ADU MODBUS Direcionada }
 Inicialización\;
 \If{Dirección hacia adelante}{
 	\tcc{Guardar el esclavo del cual provino}
	 TablaEnrutamiento[Esclavo+offset] = NodoIDRecivido;\\
	\tcc{Crear una ruta para el nodo}	 
	 TablaEnrutamiento[NodoIDRecivido] = NodoIDRecivido;\\
 }
 \Switch{Dirección}{
 	\Case{Hacia adelante}{
 		\Switch{Modo}{
			\Case{Serial}{
				Envia datos serialmente;\\	
			}
			\Case{Configuración Nodo}{
				Usa la trama para configuración propia;\\	
			}
			\Case{Salto}{
			Reenvia a la tarea \emph{espnow\_send();}	
			}
		}
	}
	\Case{Hacia atrás}{
		desMAC = RoutingTable[esclavo+offset];\\
		\If{desMAC == broadMAC}{
			\tcc{Se trata una respuesta en el maestro}	 
			Enviar a la interfaz serial;\\
		}
	}	
 }
 \caption{Algoritmo para datos recibidos unicast}\label{Algo2}
\end{algorithm}

El \emph{offset} en la tabla de enrutamiento representa a la posición a partir de la cual las rutas hacia atrás son automáticamente llenadas, para que la ruta de información sea la misma hacia adelante que hacia atrás.

Cuando se envía información se entra a la primera \emph{SEND\_CB}, si es unicast se envia cinco veces o hasta sea recibida la trama por el nodo destino. Solo cuando se incializa en nodo se envia tramas broadcast para indicar a los nodos vecinos su precencia.

En la sección de recepción tenemos que cuando se recibe broadcast se registra el nodo si no esta registrado y responde con un broadcast. Si se recibe unicast entonces se pasa a una máquina de estados que determina el destino de la información.


\subsection{Tarea espnow\_send}
Esta tarea se encarga de preparar, enrutar y enviar los datos unicast. Es activada mediante la cola \emph{espnow\_Squeue}.  El algoritmo bajo el cual se rige es el siguiente:

\begin{algorithm}[H]
\tcc{idNode: ID nodo actual}
\tcc{direcciónDe: Dirección recibida en la data}
\tcc{dataRecibida: Carga de de datos}
\KwData{idNode, direcciónDe, dataRecivida}
\KwResult{Data enviada al nodo respectivo}

\While{Se recibe información en la cola \emph{espnow\_queue}}{
desNode = TabladeEnrutamiento[Esclavo];\\
direccionA = hacia adelante;\\
\If{desNode == idNode or direcciónDe == hacia atrás}{
	desNode == TablaEnrutamiento[offset + Esclavo];\\
	direcciónA = hacia atrás;\\
}
dataAEnviar = dataRecivida;\\
espnow\_send(dataAEnviar, desNode ,direcciónA);\\
}
\caption{Algoritmo de enrutamiento de los datos en la tarea \emph{espnow\_send()}}\label{Algo3: espnowsend}
\end{algorithm}

Como se observa en el algoritmo \ref{Algo3: espnowsend}, se toma en cuenta si los datos van hacia adelante o hacia atrás, para elegir la sección de la parte de enrutamiento a usar.
\subsubsection{Direcciones MAC}
Como se dijo anteriormente, la libreria ESP-NOW usa las direcciones MAC para direccionar los datos. Ya que la tabla de enrutamiento considera solo identificadores referenciales, es necesaria la obtención de las MAC por otro método.

Cuando se envía datos broadcast las MAC son registradas en todos los dos que alcance la señal, y dicho identificador se encuentre en la tabla de enrutamiento respectiva (Observe algoritmo \ref{Algo1}). Al mismo tiempo se guarda la dirección MAC respectiva en un arreglo de 255*6 casillas, es decir, la cantidad de nodos por los campos que ocupa una dirección MAC.

Para acceder a las posiciones solo basta usar el identificador del nodo del que se desee obtener la dirección MAC, multificarla por seis y usar el número resultante como la posición a partir de la cual se tomarán seis campos.
\subsection{Programa para el manejo del protocolo Modbus en el bus RS-485.}

El ESP-IDF provee un manejador de eventos para el UART, así como estructuras de datos diseñadas para su configuración. Por lo tanto, se configuró el UART 1 para la comunicación RS-485 \emph{half-duplex}. El UART 0 esta reservado para la quema del microcontrolador y notificaciones de información y error.

El manejador de eventos proporciona una  arquitectura de maquina de estados donde se puede aceptar los datos si estos se reciben correctamente. Una vez esto pasa que crea una maquina de estados adicional para determinar el destino de la trama, que es básicamente hacia el nodo en cuestión o para un nodo externo.
 
 En el algoritmo \ref{Algo4: UARTtask} describe el funcionamiento de la rutina de la tarea \emph{rx\_task()}.
 
\begin{algorithm}
\KwData{ADU MODBUS serial}
\KwResult{Datos direccionada}
UARTinit()\;
\While{Se recibe información en la cola \emph{uart1\_queue}}{
	Limpia el buffer\;
	\Switch{Tipo de evento}{
		\Case{Datos recibidos}{
			tramaModbus = recibirDatos()\;
			dirección = obtenerDireccion(tramaModbus)\;
			\Switch{dirección}{
				\Case{Nodo externo}{
					eventoID = desdeUART;
					colaEnviar(espnow\_queue, eventoID, tramaModbus)\;				
				}
				\Case{Configuración Nodo}{
					configurarNodo(tramaModbus)\;
				}			
			}
			Limpiar buffer\;
			Resetear Cola\;
		}
		\Case{Excepciones UART}{
			Limpiar buffer\;
			Resetear Cola\;
		}
	
	}
}

\caption{Algoritmo de la tarea que administra el UART}\label{Algo4: UARTtask}
\end{algorithm}

La función \emph{UARTinit()} se encarga de incializar el uart con la configuración adecuada. Por defecto 115200 baudios, paridad desactivada, un bit de parada y modo RS-485 half-duplex.

\subsubsection{Librerías}
 
 Para el uso del UART y las estructuras de datos relevante asociadas de usan las librerias de ESP-IDF \emph{driver/uart.h}, \emph{uart\_func.h} y \emph{soc/uart\_struct.h}.
\subsection{Funciones auxiliares}
\subsubsection{Función \emph{vNotiLEDinit}}
\begin{table}[H]
\centering
\begin{tabular}{lr}
 \toprule
Nombre  & vNotiLEDinit \\
Descripción & Parpadeo de encendido\\
Parámetro &  Vacío \\
Resultado & Crea que en un pin 3 parpadeo de 1s\\
\bottomrule
\end{tabular}
\caption{Descripción de la función \emph{vNotiLEDinit} }\label{Tabla f:vNotiLED}
\end{table}

Ejecuta un parpadeo en el GPIO 2 del microcotrolador al que se le conectó un LED para indicar el que el nodo se ha encendido correctamente. 
\subsubsection{Función \emph{FormatFactory}}
\begin{table}[H]
\centering
\begin{tabular}{lr}
 \toprule
Nombre  & FormatFactory \\
Descripción & Función de la tarea de reseteo de fábrica\\
Parámetro &  Vacío \\
Resultado & Limpia la configuración del nodo\\
\bottomrule
\end{tabular}
\caption{Descripción de la función \emph{FormatFactory} }\label{Tabla f:FormatFactory}
\end{table}

Esta tarea recibe una activación mediante un semáforo binario proveniente de una interrupción por hardware en el GPIO 0, también usado como \emph{BOOT}; en caso de que se desee formatear el nodo a sus parámetros por defecto.  Se debe mantener presionado por al menos cinco segundos.

\subsubsection{Función \emph{vConfigLoad}}
\begin{table}[H]
\centering
\begin{tabular}{lr}
 \toprule
Nombre  & vConfigLoad \\
Descripción & Función para cargar la configuración al nodo\\
Parámetro &  Vacío \\
Resultado & Carga datos desde la flash a la RAM\\
\bottomrule
\end{tabular}
\caption{Descripción de la función \emph{vConfigLoad} }\label{Tabla f:vConfigLoad}
\end{table}

Esta función carga los parámetros de funcionamiento e identificación del nodo, como lo son las tablas de enrutamiento, las direcciones MAC, el identificador del nodo y la configuración del UART. Se ejcuta al energizar el nodo.

\subsubsection{Función \emph{vConfigGetNVS}}
\begin{table}[H]
\centering
\begin{tabular}{lr}
 \toprule
Nombre  & vConfigGetNVS \\
Descripción & Función para obtener datos en la flash\\
Parámetros &  Arreglo, String \\
Resultado & Carga información asociada al String en el Arreglo\\
\bottomrule
\end{tabular}
\caption{Descripción de la función \emph{vConfigGetNVS} }\label{Tabla f:vConfigGetNVS}
\end{table}

Se usa para obtener la configuración desde flash, y solo funciona para los registros de retención, tabla de MAC's y tabla de enrutamiento. Esta información de carga el parámetro del arreglo. 

Analogamente con la función \emph{vConfigSetNVS} que en ese caso carga información en la flash desde la RAM. 
\subsubsection{Función \emph{vConfigSetNode}}
\begin{table}[H]
\centering
\begin{tabular}{lr}
 \toprule
Nombre  & vConfigSetNode \\
Descripción & Función para procesar tramas Modbus\\
Parámetros &  Trama Modbus, origen (serial o inalambrico) \\
Resultado & Respuesta Modbus\\
\bottomrule
\end{tabular}
\caption{Descripción de la función \emph{vConfigGetNVS} }\label{Tabla f:vConfigSetNode}
\end{table}

Es la función asociada al Modbus de cada nodo, puede ejecutar las funciones de lectura y escritura de los registros de retención y escritura de la bobinas. Posee la capacidad de generar la respuesta inalambricamente si la solicitud fue inalámbrica o serial si la solicitud fue serial.

\subsubsection{Función \emph{uComDirection}}\label{FuncuComDir}
\begin{table}[H]
\centering
\begin{tabular}{lr}
 \toprule
Nombre  & uComDirection \\
Descripción & Comparar el esclavo de la trama con el identificador del nodo\\
Parámetros &  Esclavo \\
Resultado & Nodo externo o Nodo en cuestión\\
\bottomrule
\end{tabular}
\caption{Descripción de la función \emph{vConfigGetNVS} }\label{uComDirection}
\end{table}

Se usa en la tarea del UART para dirigir la información Modbus que se recibe, comparando el esclavo recibido con el identificador del nodo que recibió la trama. Posee una salida binaria:  va o no la trama dirigida el nodo en cuestión.

\subsubsection{Función \emph{uComGetTransData}}
\begin{table}[H]
\centering
\begin{tabular}{lr}
 \toprule
Nombre  & uComGetTransData \\
Descripción & Máquina de estados para determinar destino de la trama\\
Parámetros &  Esclavo \\
Resultado & Serial, Reenvío o configuración \\
\bottomrule
\end{tabular}
\caption{Descripción de la función \emph{uComGetTransData} }\label{Tabla f:uComGetTransData}
\end{table}

Es una función similar a la descrita en la sección \ref{uComDirection}, sin embargo, esta arroja tres posibilidades. Determina si la trama recibida debe ser enviada seriamente, reenviarse a otro nodo o simplemente configurarse a si mismo. 
\subsubsection{Función \emph{vEspnowGetOldPeers}}
\begin{table}[H]
\centering
\begin{tabular}{lr}
 \toprule
Nombre  & vEspnowGetOldPeers \\
Descripción & Registrar los nodos al iniciar\\
Parámetros &  Vacío\\
Resultado & Serial, Reenvío o configuración \\
\bottomrule
\end{tabular}
\caption{Descripción de la función \emph{vEspnowGetOldPeers} }\label{vEspnowGetOldPeers}
\end{table}

Junto con la función \emph{RegisterPeer} registra MAC de los nodos al energizar el nodo. Pues el registro se hace en la memoria volátil.
\subsubsection{Función \emph{espnow\_data\_prepare}}\label{prepare}
\begin{table}[H]
\centering
\begin{tabular}{lr}
 \toprule
Nombre  & espnow\_data\_prepare \\
Descripción & Preparar los datos a enviar\\
Parámetros &  variable \emph{send\_param}\\
Resultado & cargar datos de trama \emph{espnow}\\
\bottomrule
\end{tabular}
\caption{Descripción de la función \emph{espnow\_data\_prepare } }\label{espnowprepare }
\end{table}

Esta función prepara los trama inalámbrica, que contiene el chequeo de error, el identificador de nodo, si es unicast o broadcast, la dirección, etc. 
\subsubsection{Función \emph{espnow\_data\_parse}}
\begin{table}[H]
\centering
\begin{tabular}{lr}
 \toprule
Nombre  & espnow\_data\_parse \\
Descripción & Descompone los datos recibidos\\
Parámetros &  datos, longitud de datos, estado\\
Resultado & cargar datos de trama \emph{esp\_now} \\
\bottomrule
\end{tabular}
\caption{Descripción de la función \emph{espnow\_data\_parse} }\label{espnowparse }
\end{table}

Cumple la función complementaría a la función \ref{prepare}, descompone los datos recibidos, comprueba el chequeo de error, etc. Se usa en la maquina de estado de recepción inalámbrica.
\subsection{ Circuito de un nodo para una red WiFi mallada basada en el microcontrolador ESP32.}

El desarrollo del software de la red fue desarrollado de forma iterativa sobre las tarjetas de desarrollo, por lo que la red fue implementada miestras era desarrollada. 

Aunque el desarrollo se realizó en las tarjetas de desarrollo, y la implementación con estas es totalmente válido para realizar pruebas se diseño un circuito más específico para el nodo de la red.

Se consideran las  especificaciones del diseño en la sección \ref{hardware} y las recomendaciones  \href{https://www.espressif.com/sites/default/files/documentation/esp-wroom-02_pcb_design_and_module_placement_guide_0.pdf}{recomendaciones}técnicas realizadas por Espressif para el diseño de PCB con el ESP32.  

\subsubsection{Posicionamiento del ESP32 en el PCB}
El encapsulado  ESP-WROOM-32D está diseñada para ser soldado en una PCB huésped. La PCB de la antena usado en el ESP-WROOM-32D es una antena meandered inverted F (MIFA),  para la banda de WiFi 2,4 GHz,  con un ganancia de antena de 2dBi. La figura \ref{Fig  1: Antenna Placement} muestra las seis opciones de colocación que son comunmente usadas. La opción uno es usada como referencia. Los resultados de las pruebas ejecutadas por \emph{Espressif} muestran que las opciones 2 y 3 tienen los mejores rendimientos, mientras el de las otras son sub-óptimos.

\begin{figure}[H]
\centering
\includegraphics[scale=0.7]{opcionesPCB.png}\label{Fig  1: Antenna Placement}
\caption{Opciones para colocación en PCB}
\end{figure}

Los resultados del estudio de basan en las mediciones de potencia WiFi y parámetros EVM para varios canales de 802.11 OFDM (MCS1-7) para verificar el rendimiento del la antenas en diferentes posiciones. Los resultados fueron los siguientes:
\begin{enumerate}
\item Las opciones de colocación 1,2 y 3 basicamente no se muestran afectadas en el redimiento RF de la antena siempre y cuando esta este enfrente de espacio abierto. Es recomendado proveer una espacio de al menos 5 mm alrededor de antena en cada dirección.

\item Si el PCB de la antes tiene que ser colocado en una tarjeta huesped, es recomendada la opción 4, que no posee plano de cobre bajo la antena, así hayan algunas pérdidas del rendimiento RF.\label{recomendacion}

\item La opción 6 posee el peor rendimiento RF tanto en la trasnmisión como la recpeción, pues el rendimiento RF se ve afectado por por la tarjeta huésped.
\end{enumerate}

Por lo tanto se tomo la recomentación \ref{recomendacion} eligiendo la opción 4 para el diseño.

\subsubsection{El chip MAX-485}

\emph{Espressif} provee una ejemplo de conexión para el uso del chip MAX-485, en cual se indica la topología para usar el UART como interfaz.  Se agrega, sin embargo, una resistencia de  \emph{pull-up} en el terminal asociado a TDX para evitar niveles indeterminados en dicho pin. 


\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{maxim.png}\label{Fig  2: MAX y UART}
\caption{Ejemplo de conexión entre MAX-485 y UART}
\end{figure}

\subsubsection{Alimentación}%xxx agregar foto
Como se mencionó anteriormente, se usó la fuente LM2596S debido a una potencial rápida implementación, bajo costo y flexibilidad.  Sin embargo, la tarjeta posee un tamaño comparable al del nodo, lo que es deteminante en la arquitectura del PCB.

\subsubsection{Arquitectura Circuito Impreso}

Se considera una capa con elementos de superficie (resistencia y condensadores). La fuente se adaptada a través de pin headers en la parte posterior de la capa. Se agregan los bloques terminales para el acceso de la alimentación externa y el bus RS-485.  Así mismo, se agregaron 3 pin header para el acceso al UART 0 y dos pares de pin header adicionales para el accionamiento de las funciones de \emph{BOOT} y \emph{EN}, en el ingreso al modo de programación del microcontrolador.

Los terminales se agregaron en la parte posterior de la capa de trama para evitar obstruir el espacio libre de la antena WiFi.  En la figuras %% xxx esta y esta se presentan el esquemático electrónico y el diseño del PCB. 

Adicionalemente, se agregó un LED con el propósito de que sirva como testigo de comunicación en el encendido y durante la instalación. La tabla \ref{BOM} refleja la lista de materiales empleados  y sus características. 
\begin{table}[H]
\begin{tabular}{ccc}
 \toprule
Nombre  & Descripción & Encapsulado  \\
\midrule
D2 & Diodo  emisor de luz enviar& 1206  \\
R1 &  Resistencia 10k $\Omega$  & 1206 \\
R2 &  Resistencia 10k $\Omega$  & 1206 \\
R3 &  Resistencia 1k $\Omega$ & 01 x 03 de 2,54 mm \\
R5 &  Resistencia 10k $\Omega$ & 1206 \\
C2 &  Condensador no polarizado, 100 uF  & 1206 \\
C4 &  Condensador no polarizado, 0,1 uF  & 1206 \\
J1 &  Pin header & 01 x 03 de 2,54 mm \\
J2 &  Bloque terminal & 01 x 04 de 5.00 mm ,Altech AK300  \\
J4 &  Pin header & 01 x 02 de 2,54 mm \\
J5 &  Pin header & 01 x 02 de 2,54 mm \\
U1 & Microcontrolador &ESP32-WROOM-32 \\
U2 & Covertidor RS-485 TTL (MAX485E)& SOIC-8 \\
DCDC1 & Convertidor DC-DC LM2596 & pendiente xxx \\
\bottomrule
\end{tabular}
\caption{Lista de materiales del circuito}\label{BOM}
\end{table}
\begin{figure}[H]
\centering
\includegraphics[scale=0.7]{esquematico.eps}\label{esquematico}
\caption{Esquemático del nodo}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.7]{pcbF.eps}\label{pcbF}
\caption{Diagrama de circuito impreso capa superior}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.7]{pcbB.eps}\label{pcbB}
\caption{Diagrama de circuito impreso capa inferior}
\end{figure}


\subsection{Implementación  la red mallada diseñada}\label{implementacion}
La red mallada se implementó usando como nodos tarjetas de desarrollo junto con tarjetas para conversión RS-485 a TTL, donde aplicaba. Cada tarjeta se programó y configuró de acuerdo a la tabla \ref{Configuracion}. Se usaron un total de cuatro nodos con la topología de la figura \ref{topo}.  En el bus RS-485 del maestro se conectó un maestro Modbus proveniente de un computador a través de un convertido USB a RS-485; para enviar las tramas Modbus generadas por el software. 
\begin{table}[H]
\centering
\begin{tabular}{llr}
 \toprule
Nodo &  Descripción & Tasa de baudios serial\\
\midrule
150 & Maestro conectado & Variable\\
151 &  Esclavos conectados  & 9600\\
152 & Modo de salto & No aplica\\
153 & Esclavos conectados & 9600\\
\bottomrule
\end{tabular}
\caption{Configuración de los esclavos para la implementación}\label{Configuracion}
\end{table}

\begin{figure}[H]
\centering
\includegraphics[scale=0.7]{topo.eps}\label{topo}
\caption{Topología de implementación}
\end{figure}
Por otro lado, en el bus serial de los esclavos se conectaron unas unidades terminales remotas con capacidad de comunicación Modbus. En este caso se conectaron solo una remota por nodo. 

Las características de los equipos Modbus usados fueron los descritos en la tabla (Falta agregar). Adicionalmente la lista de materiales usada para la implementación de la red usando la tarjeta de desarrollo se presenta en la tabla \ref{BOM 2}.

\begin{table}[H]
\begin{tabular}{ccc}
 \toprule
Nombre  & Descripción & Detalle  \\
\midrule
D2 & Diodo  emisor de luz enviar& TH 5mm \\
R3 &  Resistencia 1k $\Omega$ & TH \\
U1 & Tarjeta de desarrollo & ESP32-DevKit-V1 \\
U2 & Covertidor RS-485 TTL (MAX485E)& SOIC-8 \\
Alimentación & Cable USB  y AC/DC 120VAC/5VDC& -\\
Cables  & cables protoboard  &  Cantidad 14, macho-macho\\
Protoboard  & cables protoboard  & Elego \\
\bottomrule
\end{tabular}
\caption{Lista de materiales del circuito de implementación}\label{BOM 2}
\end{table}
\subsection{Análisis el rendimiento de la red de acuerdo a variaciones en los parámetros de transmisión de datos}

Las características principales de funcionamiento de la red Modbus son: distancia entre nodos, topología, tasa de baudios de la interfaz serial, velocidad de muestreo Modbus, número de variables Modbus. Para la evaluación del rendimiento se variará un parámetro respecto al que tenga mejor desempeño del otro. Así se observa la degradación de la calidad de servicio sin caer en numerosas pruebas redundantes. 

Se comenzó con la topología descrita en la figura \ref{topo}, y para variaciones en los parámetros Modbus: velocidad de muestreo, número de variables y tasa de baudios. 

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
 \toprule
Tasa serial [Baudios]&  Número de variables& velocidad de muestreo [s]\\
\midrule
2400& 50 & 10,0 \\
4800 &  10 & 5,0 \\
9600 & 150 & 2,0 \\
19200 & 200 & 1,0 \\
38400 & - & 0,5 \\
115200 & - & 0,2 \\
\bottomrule
\end{tabular}
\caption{Variación de parámetros en la pruebas de rendiemietno}\label{parámteros}
\end{table}

Se estimará el error en función de la cantidad de excepciones Modbus que se obtengan en el maestro por cada esclavo, considerando la ecuacion \ref{Ecuacion1}
\begin{equation}
error = \dfrac{ cantidad \; de\; excepciones}{cantidad \;de \;solicitudes}  \cdot 100 \%\label{Ecuacion1}
\end{equation}

