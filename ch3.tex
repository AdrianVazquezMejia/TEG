En este capítulo se describirá el diseño de la red, detalles de software y hardware de los nodos.

\section{DISEÑO DE LA RED MALLADA}

Tomando en cuenta la investigaciones realizadas se encontró que en el campo de las redes WiFi malladas no existe un protocolo de aplicación definido, en su lugar, las redes son ajustadas a las necesidades específicas del campo en cual se vaya a implementar, esto trae como consecuencia que las especificaciones se concentren en el máximo rendimiento en las áreas críticas del problema. 

 El funcionamiento descrito en la sección \ref{primera} se concentra en el algoritmo de optimización de la topología de la red, sin tomar en consideración el hardware de implementación. Por otro lado, en la sección  \ref{segunda}, se provee una aproximación más realista, donde existen  especificaciones del hardware, sin embargo, no hay justificación para el enrutamiento usado y las medidas de rendimiento aplicadas no son de interés para el área industrial. Por último, se tiene que la ESP-MESH parecía  brindar extensibilidad y rápido desarrollo, no obstante, posee la desventaja de la necesidad de un enrutador WiFi  para la formación, que brinde las direcciones IP a la red mallada, lo que deriva en un centralización, pues si el router falla, la red perece. 

Por lo tanto, es conveniente poseer una arquitectura especifica de la red mallada para el funcionamiento dentro de una red \mb. Así se puede adaptar y configurar de manera más óptima y confiable para las funciones y características del protocolo  \mb.

Para la creación de redes inalámbricas WiFi usando el microcontrolador ESP-32, \emph{Espressif Systems} a través del \emph{ESP-IDF} (Espacio de trabajo para desarrollo de Internet de las cosas) provee dos librerías: la ya mencionada ESP-MESH y ESP-NOW.  La librería ESP-NOW fue ideada para comunicaciones punto a punto en esquemas maestro/esclavo, no para creaciones de redes multi-salto, sin embargo, posee la expansibilidad de manipular el direccionamiento de los datos, brindado la potencialidad de crear redes de diversas arquitecturas.

En la figura \ref{esperada} se muestra la ilustración de la red esperada, donde se contempla que el maestro Modbus (MA)  emita una solicitud a un eslavo mediante linea serial, los  nodos de la red toman esta información y la transmiten por la red adecuadamente para que llegue al esclavo que requiere ser interrogado. Luego la red, toma la respuesta de dicho esclavo y la entrega al maestro.  Los esclavos pueden estar a más de un salto de distancia del maestro, como es el caso del esclavo 2 (ES 2). 

\begin{figure}[H]
\centering
\includegraphics[scale=0.7]{images/topo3.eps}
\caption{Estrutura de la red esperada}\label{esperada}
\end{figure}

\subsection{ESP-NOW}
\espn  es un tipo de protocolo de comunicación WiFi definido por \emph{Espressif Systems} donde los datos de aplicación son encapsulados en una trama específica por el proveedor y es transmitida de un dispositivo \wf a otro. Para proteger la trama de acción por seguridad se usa el protocolo CCMP (Protocolo de código de autenticación de mensaje de encadenamiento de bloque de cifrado en modo contador). \espn es ampliamente usada en luces inteligente, control remoto y sensores.

\espn permite desarrollar redes según la arquitectura definida en la capa de aplicación, por lo que es ideal para la implementación de nuevas topologías y procesos de red. Además, debido a que la comunicación es punto a punto, la red no se centraliza. Así mismo, posee una capacidad de carga aceptable para la transmisión de tramas Modbus, por lo que fue la librería utilizada para el diseño e implementación de la red.


\subsection{Requerimientos de diseño} 
 
 Principalmente debe ser una red confiable, estable, y eficaz; aprovechando las principales características de las redes malladas, como saltos múltiples y descentralización. La nodos deben soportar al menos la configuración básica descrita por Modbus para linea serial garantizando la interoperatividad con otros equipos Modbus.
 Los nodos deben  ser configurables, pudiendo ajustar las rutas de la red y la tasa de baudios de la interfaz serial, para así, obtener una red extensible. 


\subsection{Diseño Básico de la red}
 Un nodo es una estación de comunicación con una dirección MAC bajo el estándar 802.11 y  una implementación de capa física (En este caso el \mcu) para la comunicación bajo este protocolo, además, constituye la entidad básica de la red.  La red más elemental, llamada  conjunto de servicios básicos (BSS), puede  ser formada por dos nodos. Para que otros nodos se unan, los integrantes del BSS provee de servicios a través de un sistema de distribución (DS) que permiten la comunicación con con dispositivos fuera del BSS para su integración.  Los enlaces se forman a partir del nodo que genere la trama (salto inicial) e indique el nodo siguiente (nodos intermedios) hasta llegar al nodo final (salto final).Los nodos involucrados en el proceso forman un BSS que permanece establecido. 
 
\subsubsection{Estructura de la trama}

Actualmente, el estándar 802.11 clasifica las tramas como de datos, de control, o de gestión. La trama de datos transmite la información en las capas más altas. Las tramas de control son usadas para agradecimientos y reservaciones. Finalmente, los dispositivos usan las tramas de gestión para configurar, organizar y mantener el enlace local.

\espn usa una trama de acción (Trama de control) específica de proveedor para transmitir datos. La tasa de transmisión por defecto es de 1 Mbps y formato de la trama es como se muestra en las tablas \ref{Tabla: espn} y \ref{Tabla: body}.
\begin{table}[H]
\caption{Trama de acción  \espn}\label{Tabla: espn}
\resizebox{15cm}{!}{
\begin{tabular}{|c|c|c|c|c|c|}
\hline 
Dirección MAC & Código de categoría & Identificador de organización & Valores aleatorios & Contenido de provedor & FCS \\ 
\hline 
24 bytes & 1 byte & 3 bytes & 4 bytes & 7-255 bytes & 4 bytes \\ 
\hline 
\end{tabular}
}
\end{table}

\begin{enumerate}
\item Código de categoría:  es establecido en 127 para indicar la trama específica de proveedor.
\item Identificador de organización:  contiene un identificador único (0x18fe34), los cuales son las primeros tres bytes de la MAC aplicada por \emph{Espressif}.
\item Valores aleatorios: son usador para prevenir ataques de retransmisión.
\item Contenido de proveedor: Contenido de específico de proveedor, contiene datos adicionales.
\item FCS: Trama de chequeo de errores.
\end{enumerate}
 
\begin{table}[H]
\caption{Contenido de específico de proveedor}\label{Tabla: body}
\resizebox{15cm}{!}{
\begin{tabular}{|c|c|c|c|c|c|}
\hline 
ID de elemento& Longitud & ID de organización & Tipo & Versión & Cuerpo\\ 
\hline 
1 byte & 1 byte & 3 bytes & 1 byte & 1  bytes & 9 - 250 bytes \\ 
\hline 
\end{tabular} 
}
\end{table}
\begin{enumerate}
\item  ID de elemento: Es establecido en 221, para indicar elemento de específico de proveedor.
\item Longitud: Es la longitud total de ID de organización, tipo, version  y cuerpo.
\item Tipo: Es establecido en 4, para indicar \espn.
\item Versión: Versión de \espn.
\item Cuerpo: El  cuerpo contiene los datas \espn.
\end{enumerate}

En el protocolo \espn la cabecera MAC varia respecto a las convencionales, el primer campo es dedicado a la dirección destino, la segunda la dirección de origen y la tercera es usada para establecer la dirección broadcast (0xFF:0xFF:0xFF:0xFF:0xFF:0xFF).En las tramas \espn los bits de control de tramas \textit{FromDS} y \textit{ToDS} son ambos cero. 

Los campos de gestión que indican las direcciones MAC son usados para mantener la red, y el servicio de distribución para ingresar nuevos nodos, se logra a partir de la dirección broadcast. 

Los campos de cuerpo de la trama también son usados para manejar la comunicación en la red mallada en la capa de aplicación, cada nodo posee una lógica dependiente de la tramas recibidas. La estructura de datos del cuerpo toma la forma definida en la tabla \ref{Estructura}.

\begin{table}[H]
\caption{Estructura de datos envidada en el cuerpo de la trama \espn}\label{Estructura}
\centering
\begin{tabular}{|c|c|}
\hline 
type & Broadcast o unicast \\ 
\hline 
state & Indica si se han recibido datos broadcast  \\ 
\hline 
seq\_num & Numero de secuencia \\ 
\hline 
crc & Crc de los datos \\ 
\hline 
dir & Dirección desde o hacia el maestro \\ 
\hline 
Nodeid & Identificador del nodo \\ 
\hline 
payload & Carga  \\ 
\hline 
data\_len & Longitud de los datos \\ 
\hline 
\end{tabular}
\end{table}

\subsubsection{Gestión y formación mallada}

Una señal broadcast proveniente de un nodo se usa para detectar la red y obtener información sobre su configuración. Los nodos se detectan entre sí en un escaneo activo. La trama de escaneo se identifica debido a que es generada mediante broadcast. La información recibida posee tres campos claves: información del identificador del nodo, si se ha recibido o no información broadcast antes del nodo por el que se está buscando y un campo adicional Modbus. El escaneo se realiza cuando un nodo no posee la dirección MAC de otro nodo en su tabla de enrutamiento y se requiere enviar datos a este. La fuente de datos posee el esclavo Modbus destino, lo que es usado para registrar solo aquellos nodos que tengan relación con el esclavo particular.  Una vez los nodos se han registrado unos a otros la relación permanece, incluso si algún nodo es apagado, una vez sea se reinicie la red permite una rápida reconexión.

Los nodos solo usan un transceptor simple, por lo tanto, la red mallada opera en un solo canal de frecuencia WiFi. Esto indica que se puede colocar una red en cada canal WiFi en un mismo espacio físico, sin llegar a tener conflictos de este tipo. 

\subsubsection{Seguridad}
Cada nodo \espn usa el método CCMP, el cual está descrito en el estándar 802.11- 2012, para proteger la trama de acción específica del proveedor. Esto junto con un algoritmo de cifrado mutuo, los nodos emparejados usan una llave maestra primaria (PMK) que es usada para cifrar las  llaves de cifrado locales (LMK) con el algoritmo AES-128. Este método de permite la autenticación entre dos nodos emparejados. Debido a que es un cifrado por emparejamiento, cada vínculo es independientemente asegurado, como consecuencia, \espn no provee cifrado fin-a-fin. 

El cifrado para comunicación broadcast no esta soportado. Las llaves locales son usadas por el método CCMP y cada nodo puede contener hasta seis llaves diferentes, si la llave local no se establece la trama de acción permanece sin cifrado. 
%agregar esquema 

\subsubsection{Selección de rutas}

Las rutas no son determinadas por la red, si no por el usuario que la implemente. Además, son estáticas y no se reasignan automáticamente, estas rutas permanecen en una tabla unidimensional, con los identificadores de los nodos destinos. El enrutamiento está estrechamente relacionado con los esclavos Modbus, y están representados por las posiciones en la tabla de enrutamiento.

La red no propaga información de las rutas, por lo que cada nodo solo conoce la ruta para una salto en cualquier sentido. Sin embargo, es posible solicitar y configurar las rutas de los nodos inalambricamente.

La tabla de enrutamiento posee 256 casillas (una para cada esclavo Modbus), donde la posición está asociada al esclavo Modbus y el valor en la casilla se relaciona con la ubicación de dicho esclavo. Cabe resaltar que el identificador al que se refiere la tabla de enrutamiento como destino no es la localización del esclavo en la red. En la figura \ref{Fig  2: Tabla de enrutamiento} se ilustra en la arquitectura e interpretación de la tabla de enrutamiento asociada al nodo 255.
 

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{rt.eps}
\caption{Ilustración de la estructuras de la tabla de enrutamiento}\label{Fig  2: Tabla de enrutamiento}
\end{figure}

Existe otra tabla de enrutamiento para las respuestas, de manera tal que las rutas sean bidireccionales y únicas. La tabla de respuesta es configurada y mantenida automáticamente por cada nodo. Cuando se reciben solicitudes Modbus, se guarda el identificador del nodo del cual provino dicha información, y dicho identificador se usa para enrutar la trama respuesta.

 Un esquema del funcionamiento se puede apreciar en las figuras \ref{Fig 1: ULM enrutamiento} y \ref{Fig 1: ULM serial}.
 
 \begin{figure}[H]
\centering
\includegraphics[scale=0.4]{UML2.eps}
\caption{Diagrama de flujo del funcionamiento general de un nodo de la red recibiendo información WiFi}\label{Fig 1: ULM enrutamiento}
\end{figure}

 \begin{figure}[H]
\centering
\includegraphics[scale=0.4]{UMLSerial.eps}
\caption{Diagrama de flujo del funcionamiento general de un nodo de la red recibiendo información serial}\label{Fig 1: ULM serial}
\end{figure}

\subsubsection{Características Modbus de los nodos}
 
Los nodos de la red son esclavos adicionales de la red Modbus, con direcciones reservadas para ellos desde el identificador ciento uno (101). El modo de operación Modbus en los nodos permite que se puedan obtener  y configurar parámetros de la red, como la tabla de enrutamiento de los nodos. Además el proceso es realizado mediante un protocolo estandarizado y que esta relacionado con la red.

El funcionamiento como esclavo Modbus en los nodos es permanente, incluso cuando ya se ha implementado la red con equipos Modbus seriales externos, permitiendo actualización de parámetro de la red en cualquier momento. 

Los nodos poseen un diagnóstico visual que indica cuando se ha recibido o enviado correctamente una trama  serial o inalambricamente. Dicho diagnóstico de basa en un LED que emite un pulso. Otro diagnóstico visual para indicar que se ha encendido el equipo, del mismo tipo se encuentra en la tarjeta de alimentación. No hay diagnostico visual para errores de comunicación.%observe hardaware para mas detalle.

Los registros disponibles para acceso son los registros de retención desde la dirección cero hasta la 512, y también las diez primeras bobinas. Para las bobinas solo es soportada la función de escribir una bobina simple. La tabla \ref{Tabla 1: Espec HR} describe la asignación de los registros.


 
\begin{table}[H]
\caption{Tablas primarias de los modelos de datos Modbus}\label{Tabla 1: Espec HR}
\centering
\begin{tabular}{|c|c|c|}
\hline
Dirección & Tipo de registro & Descripción  \\
\hline
01 & Registros de retención & Identificador \\
\hline
02 & Registros de retención    &  Tasa de baudios  \\
\hline
256-512 & Registros de retención  & Tabla de enrutamiento\\
\hline
0 & Bobina &Reinicio \\
\hline
1 & Bobina &Guardar valores Modbus para ejecución\\
\hline
2 & Bobina &Guardar valores Modbus en  la memoria Flash\\
\hline
\end{tabular}
\end{table}

La tabla \ref{Tabla 1: Espec Modbus} posee una descripción de la parámetros Modbus.
\begin{table}[H]
\caption{Parámtros Modbus}\label{Tabla 1: Espec Modbus}
\centering
\begin{tabular}{|c|c|c|}
 \hline
Dirección & Por defecto & Opciones \\
\hline
ID Modbus & 255 & 101 a 255 \\
\hline
Tasa de baudios serial & 19200   &  300 a 115200 \\
\hline
Tabla enrutamiento & Nula &Valores válidos de ID Modbus \\
\hline
Modo & RTU & Ninguna \\
\hline
Paridad & Ninguna & Ninguna \\
\hline
Bits de parada & 1 & Ninguna \\
\hline
\end{tabular}
\end{table}

Cabe resaltar que estos nodos pueden ser interrogados tanto serial como inalambricamente, es decir, con la red ya instalada. Las funciones no usadas proveerán la excepción Modbus "Función ilegal". 

\subsubsection{El hardware}\label{hardware}

El hardware del nodo se puede dividir en tres bloques: el microcontrolador, la alimentación y la interfaz serial. Esto se puede ilustrar en el esquema de la figura \ref{Fig  4: Diagrama de bloques}.
\begin{figure}[H]

\centering
\includegraphics[scale=0.5]{diagrama.eps}
\caption{Diagrama de bloques para el hardware del nodo}\label{Fig  4: Diagrama de bloques}
\end{figure}


\textbf{Microcontrolador}

Para la aplicación se usó el encapsulado  ESP-WROOM-32, debido a disponibilidad y encapsulado con escudo WiFi.  Se debe tener en cuenta que se dejaron disponibles los pines del UART0 para la descarga del software, además de dos pines adicionales para inducir el estado de programación, los cuales son el pin \textit{EN} y el pin de propósito general cero.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{ESP-WROOM-32.jpg}
\captionsource{Encapsulado ESP-WROOM-32 del ESP32}{Adaptada de \cite{imEncap}}\label{Fig  x: ESP-WROOM-32}
\end{figure}
 
\textbf{Alimentación}
La alimentación del microcontrolador es de 3,3 V y además los equipos Modbus especifican un rango de tensión de funcionamiento entre 5 V y 25 V. Por lo tanto se escogió el regulador conmutado LM2596S que brinda estas características y además existe una tarjeta pre-fabricada para rápida implementación. La figura \ref{dcdcF} muestra la forma de dicha tarjeta. Además posee un LED testigo de su encendido, que es usado como señal de diagnóstico Modbus.

\begin{figure}[H]
\centering
\includegraphics[scale=1]{dcdc.jpg}
\captionsource{Tarjeta con regulador DC-DC para alimentación}{Adaptada de \citep{imEncapDC}}\label{dcdcF}
\end{figure}
 %Otras especifiaciones
 
 Las características eléctricas son presentadas en la tabla \ref{Espec dcdc}
 \begin{table}
 \caption{Especificaciones de la fuente de alimentación}\label{Espec dcdc}
 \centering
 \begin{tabular}{|c|c|}
 \hline 
 Voltaje de entrada & 4 V - 35 V \\ 
 \hline 
 Voltajes de salida & 1,23 V 30 V \\ 
 \hline 
 Corriente de entrada &  3 A (Máxima) \\ 
 \hline 
 Eficiencia de conversión & 92\% (Máxima) \\ 
 \hline 
 Frecuencia de conmutación & 150 kHz \\ 
 \hline 
 Ripple de salida &  30 mA (Máximo) \\ 
 \hline 
 \end{tabular} 
 \end{table}

\textbf{Interfaz serial}

Modbus en sus clases básica dicta que los equipos Modbus  seriales tienen que poseer la interfaz eléctrica RS-485 de dos cables de acuerdo con el estándar EIA/TIA-485. Por esto se seleccionó para la implementación en el nodo, asegurando la máxima compatibilidad. 

El chip MAX3485 de \emph{Maxim Integrated} provee de las características antes descritas y admite tensión de alimentación de 3,3 V, lo cual hace que se posea un solo nivel de tensión para la alimentación del nodo.

Este chip soporta hasta 32 dispositivos, sin embargo, el uso de nodos distribuye la carga de los esclavos y  la utilización de repetidores se vería disminuida, y se soportarían 32 dispositivos por cada nodo.

La topología RS-485 Modbus sin repetidor posee cables truncados en un par trenzado, sobre los cuales los dispositivos están conectados bien sea directamente o a través de cables de derivación. Los cables truncados también llamado bus, cuya longitud depende de la tasa de baudios, los parámetros del cable y  la carga de dispositivos, para 9600 baudios y un cable calibre de 26 AWG, la máxima longitud es de 1000 m. 

Las derivaciones no deben estar a más de 20 m. En caso del uso de una derivación de puertos múltiples con $n$ derivaciones, cada una tiene que respetar una distancia máxima de 40 m dividida por $n$.

El circuito común de cada bus debe estar conectado a tierra, preferiblemente a un solo punto para todo el bus.  Esto no aplica para la red, pues evidentemente la comunicación inalámbrica brinda aislamiento galvánico.

Para minimizar las reflexiones del final del cable RS-485, se requiere colocar un terminador de linea cerca del final de cada punto del bus (Resistencia de 150 $\Omega$ y 0,5 W). No se deben colocar más de dos terminadores de linea en el bus, ni colocar terminadores de linea en los cable de derivación.

Si el sistema requiere polarización esta de debe implementar en cada bus serial del sistema, los nodos inalámbricos no requieren polarización.

La interfaz mecánica consta de de Bloques terminales, la identificación  RS-485 se encuentra en la el circuito impreso.

Los cables de la linea serial deben estar blindados, deben formar una par balanceado y deben poseer un tercer cable (Común).  Estos deben posee el calibre suficiente para permitir la máxima distancia. Un calibre de 24 AWG es siempre suficiente. Además, preferiblemente se debe seleccionar cables con una impedancia características mayor a 100 $\Omega$, especialmente para tasas de Baudios mayores a 19200.

\section{Detalle del Diseño}
\subsection{Programación del ESP-32}
El fabricante del \mcu \textit{Espressif Systems} especifica  los recursos básicos de hardware y software relacionados con el desarrollo de aplicaciones que usen la serie de hardware del ESP32.

El hardware necesario son: una tarjeta de desarrollo con un ESP32, un cable USB y computador que posea Windows, Linux o MACOS. Para el desarrollo del programa se usaron tarjetas de desarrollo ESP32-DevKitC V1 y un computador con sistema operativo Ubuntu 18.04 LTS.

En cuanto al software se puede representar por capas:
\begin{enumerate}
\item Un \textbf{Toolchain} para compilar el código para el ESP32: Xtensa-ELF 1.22.0.
\item \textbf{Herramientas de construcción}  para construir toda la aplicación para el microcontrolador, en este caso se usó  \textit{GNU Make} 4.1.
\item ESP-IDF  que contiene esencialmente las librerias y los scripts para operar con el \textbf{Toolchain}, versión 4.0.
\item \textbf{Editor de texto } para escribir los programas en C, en este caso \textit{Eclipse IDE} 2019-12.
\end{enumerate}


 \begin{figure}[H]
\centering
\includegraphics[scale=0.5]{toolchain.png}
\caption{Ilustración del paquete para el desarrollo de aplicaciones en el ESP32 }{Adaptada de \cite{imTool} }\label{Fig  3: Desarrollo de aplicaciones}
\end{figure}

Los detalles de la instalación de cada uno de estas herramientas se llevo a cabo siguiendo la metodología propuesta por \textit{Espressif } en el su pagina web \url{https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/index.html}.


\subsubsection{El sistema operativo en tiempo real}

El microcontrolador ESP32 está diseñado para correr un sistema operativo en tiempo real(RTOS) basado en el  \textit{FreeRTOS} desarrollado por \textit{Amazon}..La lógica funcional del método de programación RTOS es mediante establecimiento de tareas e interrupciones controladas por orden de prioridad y por el temporizador principal del sistema. 

Dicho sistema operativo permite que se creen y desarrollen programas en lenguaje ANSI C, implementado las librerías para el manejo del microcontrolador proveídas por ESP-IDF de \textit{espressif}. Por lo tanto, el desarrollo del programa se basó en la creación de tareas y la comunicación entre ellas basada en colas. Se crearon tareas dos tareas para el manejo de los datos inalámbricos, una para la recepción de datos mediante el UART  y otras tareas con funciones de monitorización.

\subsection{ Programa de la red diseñada que soporte la transmisión del protocolo Modbus}

El rol de cada nodo en la red es determinado por la secuencia de estados durante operación, por lo que el programa es idéntico para todos los microcontroladores, incluido el que posee conectado el maestro. Cualquier nodo puede enviar datos, incluso aquellos que posee esclavos Modbus en su interfaz serial.
  
  
  En primer lugar se definen en la aplicación principal (\textit{app\_main}) las funciones que se llevaran a cabo al iniciar el microcontrolador. La inicialización de la flash, el módulo WiFi, el UART y la creación de tareas toma lugar en esta parte. Esta sección se ejecuta solo una vez. 
\subsubsection{Librerías}
 En el programa se incluyen la librerías estándar de C  <stdlib.h> , <time.h>, <string.h>, y  <assert.h>, para el uso y manejo de las principales funciones de C. Luego tenemos que freertos/file.h provee del las funciones necesarias parar la ejecución y uso del sistema operativo en tiempo real.  Restando las inclusiones asociadas al ESP-IDF para el uso de las librerías de funciones del microcontrolador.
 
 La librería nvs\_flash.h, habilita para el uso de la funciones de acceso a la flash, necesarias para guardar y cargar la configuración a los nodos.
 
 Las inclusiones  esp\_log.h, esp\_system.h, esp32/rom/ets\_sys.h, esp32/rom/ets\_sys.h y esp32/rom/crc.h permiten el uso del sistema del ESP-32 para el acceso a estado del sistema como estado de la pila, reinicio, etc.
 
 Finalmente, para el uso de las funciones para la construcción de la red mallada son necesarias las inclusiones siguientes: tcpip\_adapter.h, esp\_wifi.h, esp\_now.h, espdefine.h
 
\subsubsection{Inicialización}
La rutina para las tareas de la red mallada comienzan con la inicialización del periferico WiFi y funciones \espn mediante las funciones \emph{wifi\_init()} y \emph{espnow\_init()} respectivamente.
  
Con la función  \emph{wifi\_init()} se inicializan el adaptador TCP/IP, el manejador de eventos WiFi y se carga la confiuración, en este caso como sigue:
\begin{enumerate}
\item Modo de punto de acceso
\item Canal cero
\item Modo de largo alcance
\item Soporte de los protocolos 802.11b,802.11g y 802.11n.
\end{enumerate}

Luego tenemos la función  \emph{espnow\_init()} que prepara las variables iniciales, crea las colas de recepción y envío, registra las funciones de \textit{callback} de recepción y envío, establece las claves de encriptación, registra los nodos y crea la tareas.

\subsubsection{Creación de colas (\emph{Queue})}
 
 En la inicialización se crean tres colas: 
 \begin{enumerate}
 \item \emph{espnow\_queue} que se usa para transmitir los datos de las funciones de \textit{callback}  a las tareas que manejan la red. 

 \item \emph{espnow\_Squeue} se usa para la transmisión de los datos desde la tarea asociada al UART.
 
  \item \emph{espnow\_Rqueue} se usa para transmitir los datos hacia la tarea que envía información inalambricamente.
 \end{enumerate}
 
 \subsubsection{Las funciones de callback}
 
 Estas son funciones escritas por el programador que son llamadas dentro del pila WiFi automáticamente, y permite que la información del proceso de enviar y recibir se pueda manejar desde otras funciones o tareas más complejas. El fabricante recomienda que se mantengan cortas dichas funciones, que en su lugar se use una cola y se maneje la información desde otras funciones.
 
 Estas funciones son activadas cuando se envía o recibe información mediante \espn, proveen información de la MAC, bandera de agradecimiento, longitud de los datos y los datos. Básicamente vinculan la comunicación WiFi a la aplicación principal.
 
 \subsubsection{Registro de puntos}
 
 En la librería \emph{espnow} existen unos entes llamados \emph{Peers} (Puntos), los cuales conservan la información de emparejamiento. Si un peer no está registrado, es imposible enviar información a el o recibirla. Hay un peer virtual para enviar información brodacast cuya característica es la dirección MAC, la cual es la mayor posible (FF:FF:FF:FF:FF:FF).
 
 Los campos de cada puntos son los descritos en la tabla \ref{Tabla 2: información de peers}
 
\begin{table}[H]
\caption{Tablas primarias de los modelos de datos Modbus}\label{Tabla 2: información de peers}
\centering
\begin{tabular}{lr}
 \toprule
Parámetro & Descripción  \\
\midrule
peer address &  Dirección MAC \\
lmk & Clave maestra local que es usada para cifrar los datos  \\
channel & Canal WiFi\\
ifidx & Interface que usa el WiFi para enviar y recibir datos \\
encrypt & Habilitador de cifrado \\
*priv & Datos privados de la librería  \\
\bottomrule
\end{tabular}
\end{table}

La información de los puntos es guardada mediante la función \emph{esp\_now\_add\_peer()}.
\subsubsection{Estructuras de datos relevantes}

Se crearon ciertas estructuras usando el lenguaje C, para manejar los datos con mayor facilidad y orden. 

\begin{enumerate}
\item \emph{espnow\_send\_param\_t}: esta estructura esta diseñada para contener los datos en la transmisión de los datos. Indica si la trama es unicast o bradcast. La longitud de los datos, los datos a enviar, el número de secuencia, el estado de la transmisión, etc.

\item \emph{espnow\_event\_t} : es la estrutura usada para manejar los estados nodo. Permite que posea información relacionada con los datos trasmitidos, la dirección y el estado. 


\item \emph{esp\_uart\_data\_t}: Esta estructura de datos se creó para comunicar las tareas del UART y las de ESP-NOW, no solo posee los datos recibidos si no también el sentido en la red de estos. 
\end{enumerate}



\subsection{Tarea esp\_now\_manage\_task}

Es la tarea principal del sistema de comunicación inalámbrica, y es administrada por la cola \emph{espnow\_queue}. Cabe mencionar que las colas permiten que la tarea se ejecute solo si se recibió un dato en ella, lo cual ayuda mantener la eficiencia del procesador.

En esta tarea se verifica si se estaba enviando o recibiendo datos y ejecuta los  procesos respectivos en cada caso, considerando si es broadcast o unicast.

La cola se habilita por las funciones de \emph{callback}, por la tarea del UART y la función Modbus.

A continuación se presenta pseudocódigo de la ejecución de la tarea.\\
%%%Pseudo codigo goes here.
\begin{algorithm}[H]
 \KwData{ADU MODBUS, EVENT\_DATA}
 \KwResult{ADU MODBUS ADMINISTRADA }
 Inicialización\;
 \While{Se recibe \emph{Evento ID} en la cola}{
 	\Switch{Evento ID}{
		\Case{Enviar}{ 
			\Switch{Origen}{
				\Case{De la función de Callback}{
					\eIf{desMAC == broadMAC}{
						\If{contador ==0}{break}
							contador--;\\
							Enviar broadcast;\\
					}{
					\eIf{estado de envío == exito \emph{or} intentsos == 5}{break;}{
						Intentos ++\\
						Enviar a la cola espnow\_Squeue;\\
					}						
					}
				}
				\Case {Primer intento de envió}{
					Enviar a la cola espnow\_Squeue;\\
				}			
				
		} 
		\Case{Desde recibir}{
			\eIf{Broadcast}{
				\If{Nodo no está registrado}{
					Registrar nodo;\\
				}
			}{\eIf{Unicast}{
				\emph{UnicastAlgo();}
			}
			{Error}				
			}			
			}
		}
 	}
 }

 \caption{Algoritmo tarea esp\_now\_manage\_task}\label{Algo1}
\end{algorithm}[H]


\begin{algorithm}
 \KwData{ADU MODBUS, EVENT\_DATA}
 \KwResult{ADU MODBUS Direcionada }
 Inicialización\;
 \If{Dirección hacia adelante}{
 	\tcc{Guardar el esclavo del cual provino}
	 TablaEnrutamiento[Esclavo+offset] = NodoIDRecivido;\\
	\tcc{Crear una ruta para el nodo}	 
	 TablaEnrutamiento[NodoIDRecivido] = NodoIDRecivido;\\
 }
 \Switch{Dirección}{
 	\Case{Hacia adelante}{
 		\Switch{Modo}{
			\Case{Serial}{
				Envia datos serialmente;\\	
			}
			\Case{Configuración Nodo}{
				Usa la trama para configuración propia;\\	
			}
			\Case{Salto}{
			Reenvia a la tarea \emph{espnow\_send();}	
			}
		}
	}
	\Case{Hacia atrás}{
		desMAC = RoutingTable[esclavo+offset];\\
		\If{desMAC == broadMAC}{
			\tcc{Se trata una respuesta en el maestro}	 
			Enviar a la interfaz serial;\\
		}
	}	
 }
 \caption{Algoritmo para datos recibidos unicast (\textit{UnicastAlgo()})}\label{Algo2}
\end{algorithm}

El \emph{offset} en la tabla de enrutamiento representa a la posición a partir de la cual las rutas hacia atrás son automáticamente llenadas, para que la ruta de información sea la misma hacia adelante que hacia atrás.

Cuando se envía información se entra a la primera \emph{SEND\_CB}, si es unicast se realizan cinco intentos de envío o hasta sea recibida la trama por el nodo destino. Solo cuando se inicializa en nodo se envían tramas broadcast para indicar a los nodos vecinos su presencia.

En la sección de recepción tenemos que cuando se recibe broadcast se registra el nodo si no esta registrado y responde con un broadcast. Si se recibe unicast entonces se pasa a una máquina de estados que determina el destino de la información.


\subsection{Tarea espnow\_send}
Esta tarea se encarga de preparar, enrutar y enviar los datos unicast. Es activada mediante la cola \emph{espnow\_Squeue}.  El algoritmo bajo el cual se rige es el \ref{Algo3: espnowsend}.

\begin{algorithm}[H]
\tcc{idNode: ID nodo actual}
\tcc{direcciónDe: Dirección recibida en la data}
\tcc{dataRecibida: Carga de de datos}
\KwData{idNode, direcciónDe, dataRecivida}
\KwResult{Data enviada al nodo respectivo}

\While{Se recibe información en la cola \emph{espnow\_queue}}{
desNode = TabladeEnrutamiento[Esclavo];\\
direccionA = hacia adelante;\\
\If{desNode == idNode or direcciónDe == hacia atrás}{
	desNode == TablaEnrutamiento[offset + Esclavo];\\
	direcciónA = hacia atrás;\\
}
dataAEnviar = dataRecivida;\\
espnow\_send(dataAEnviar, desNode ,direcciónA);\\
}
\caption{Algoritmo de enrutamiento de los datos en la tarea \emph{espnow\_send()}}\label{Algo3: espnowsend}
\end{algorithm}

Como se observa en el algoritmo \ref{Algo3: espnowsend}, se toma en cuenta si los datos van hacia adelante o hacia atrás, para elegir la sección de la parte de enrutamiento a usar.
\subsubsection{Direcciones MAC}
Como se dijo anteriormente, la libreria \espn usa las direcciones MAC para direccionar los datos. Ya que la tabla de enrutamiento considera solo identificadores referenciales, es necesaria la obtención de las MAC por otro método.

Cuando se envía datos broadcast las MAC son registradas en todos los dos que alcance la señal, y dicho identificador se encuentre en la tabla de enrutamiento respectiva (Observe algoritmo \ref{Algo1}). Al mismo tiempo se guarda la dirección MAC respectiva en un arreglo de ($255\, x \, 6$) casillas, es decir, la cantidad de nodos por los campos que ocupa una dirección MAC.

Para acceder a las posiciones solo basta usar el identificador del nodo del que se desee obtener la dirección MAC, multiplicarla por seis y usar el número resultante como la posición a partir de la cual se tomarán seis campos.
\subsection{Programa para el manejo del protocolo Modbus en el bus RS-485.}

El ESP-IDF provee un manejador de eventos para el UART, así como estructuras de datos diseñadas para su configuración. Por lo tanto, se configuró el UART 1 para la comunicación RS-485 \emph{half-duplex}. El UART 0 esta reservado para la quema del microcontrolador y notificaciones de información y error.

El manejador de eventos proporciona una  arquitectura de máquina de estados donde se puede aceptar los datos si estos se reciben correctamente. Una vez esto pasa se crea una máquina de estados adicional para determinar el destino de la trama, que es básicamente hacia el nodo en cuestión o para un nodo externo.
 
 En el algoritmo \ref{Algo4: UARTtask} describe el funcionamiento de la rutina de la tarea \emph{rx\_task()}.
 
\begin{algorithm}
\KwData{ADU MODBUS serial}
\KwResult{Datos direccionada}
UARTinit()\;
\While{Se recibe información en la cola \emph{uart1\_queue}}{
	Limpia el buffer\;
	\Switch{Tipo de evento}{
		\Case{Datos recibidos}{
			tramaModbus = recibirDatos()\;
			dirección = obtenerDireccion(tramaModbus)\;
			\Switch{dirección}{
				\Case{Nodo externo}{
					eventoID = desdeUART;
					colaEnviar(espnow\_queue, eventoID, tramaModbus)\;				
				}
				\Case{Configuración Nodo}{
					configurarNodo(tramaModbus)\;
				}			
			}
			Limpiar buffer\;
			Resetear Cola\;
		}
		\Case{Excepciones UART}{
			Limpiar buffer\;
			Resetear Cola\;
		}
	
	}
}

\caption{Algoritmo de la tarea que administra el UART}\label{Algo4: UARTtask}
\end{algorithm}

La función \emph{UARTinit()} se encarga de incializar el uart con la configuración adecuada.

\subsubsection{Librerías}
 
 Para el uso del UART y las estructuras de datos relevante asociadas de usan las librerias de ESP-IDF \emph{driver/uart.h}, \emph{uart\_func.h} y \emph{soc/uart\_struct.h}.
\subsection{Funciones auxiliares}
\subsubsection{Función \emph{vNotiLEDinit}}
\begin{table}[H]
\caption{Descripción de la función \emph{vNotiLEDinit}}\label{Tabla f:vNotiLED}
\centering
\begin{tabular}{|c|c|}
\hline
Nombre  & vNotiLEDinit \\
\hline
Descripción & Parpadeo de encendido\\
\hline
Parámetro &  Vacío \\
\hline
Resultado & Crea que en un pin 3 parpadeo de 1s\\
\hline
\end{tabular}
\end{table}

Ejecuta un parpadeo en el GPIO 2 del microcotrolador al que se le conectó un LED para indicar el que el nodo se ha encendido correctamente. 
\subsubsection{Función \emph{FormatFactory}}
\begin{table}[H]
\caption{Descripción de la función \emph{FormatFactory} }\label{Tabla f:FormatFactory}
\centering
\begin{tabular}{|c|c|}
\hline
Nombre  & FormatFactory \\
\hline
Descripción & Función de la tarea de reseteo de fábrica\\
\hline
Parámetro &  Vacío \\
\hline
Resultado & Limpia la configuración del nodo\\
\hline
\end{tabular}
\end{table}

Esta tarea recibe una activación mediante un semáforo binario proveniente de una interrupción por hardware en el GPIO 0, también usado como \emph{BOOT}; en caso de que se desee formatear el nodo a sus parámetros por defecto.  Se debe mantener presionado por al menos cinco segundos.

\subsubsection{Función \emph{vConfigLoad}}
\begin{table}[H]
\caption{Descripción de la función \emph{vConfigLoad} }\label{Tabla f:vConfigLoad}
\centering
\begin{tabular}{|c|c|}
\hline
Nombre  & vConfigLoad \\
\hline
Descripción & Función para cargar la configuración al nodo\\
\hline
Parámetro &  Vacío \\
\hline
Resultado & Carga datos desde la flash a la RAM\\
\hline
\end{tabular}
\end{table}

Esta función carga los parámetros de funcionamiento e identificación del nodo, como lo son las tablas de enrutamiento, las direcciones MAC, el identificador del nodo y la configuración del UART. Se ejecuta al energizar el nodo.

\subsubsection{Función \emph{vConfigGetNVS}}
\begin{table}[H]
\caption{Descripción de la función \emph{vConfigGetNVS} }\label{Tabla f:vConfigGetNVS}
\centering
\begin{tabular}{|c|c|}
\hline
Nombre  & vConfigGetNVS \\
\hline
Descripción & Función para obtener datos en la flash\\
\hline
Parámetros &  Arreglo, String \\
\hline
Resultado & Carga información asociada al String en el Arreglo\\
\hline
\end{tabular}
\end{table}

Se usa para obtener la configuración desde flash, y solo funciona para los registros de retención, tabla de MAC's y tabla de enrutamiento. Esta información de carga el parámetro del arreglo. 

Análogamente con la función \emph{vConfigSetNVS} que en ese caso carga información en la flash desde la RAM. 
\subsubsection{Función \emph{vConfigSetNode}}
\begin{table}[H]
\caption{Descripción de la función \emph{vConfigGetNVS} }\label{Tabla f:vConfigSetNode}
\centering
\begin{tabular}{|c|c|}
\hline
Nombre  & vConfigSetNode \\
\hline
Descripción & Función para procesar tramas Modbus\\
\hline
Parámetros &  Trama Modbus, origen (serial o inalambrico) \\
\hline
Resultado & Respuesta Modbus\\
\hline
\end{tabular}
\end{table}

Es la función asociada al Modbus de cada nodo, puede ejecutar las funciones de lectura y escritura de los registros de retención y escritura de la bobinas. Posee la capacidad de generar la respuesta inalambricamente si la solicitud fue inalámbrica o serial si la solicitud fue serial.

\subsubsection{Función \emph{uComDirection}}\label{FuncuComDir}
\begin{table}[H]
\caption{Descripción de la función \emph{vConfigGetNVS} }\label{uComDirection}
\centering
\begin{tabular}{|c|c|}
\hline
Nombre  & uComDirection \\
\hline
Descripción & Comparar el esclavo de la trama con el identificador del nodo\\
\hline
Parámetros &  Esclavo \\
\hline
Resultado & Nodo externo o Nodo en cuestión\\
\hline
\end{tabular}
\end{table}

Se usa en la tarea del UART para dirigir la información Modbus que se recibe, comparando el esclavo recibido con el identificador del nodo que recibió la trama. Posee una salida binaria:  va o no la trama dirigida el nodo en cuestión.

\subsubsection{Función \emph{uComGetTransData}}
\begin{table}[H]
\caption{Descripción de la función \emph{uComGetTransData} }\label{Tabla f:uComGetTransData}
\centering
\begin{tabular}{|c|c|}
\hline
Nombre  & uComGetTransData \\
\hline
Descripción & Máquina de estados para determinar destino de la trama\\
\hline
Parámetros &  Esclavo \\
\hline
Resultado & Serial, Reenvío o configuración \\
\hline
\end{tabular}
\end{table}

Es una función similar a la descrita en la sección \ref{uComDirection}, sin embargo, esta arroja tres posibilidades. Determina si la trama recibida debe ser enviada seriamente, reenviarse a otro nodo o simplemente configurarse a sí mismo. 
\subsubsection{Función \emph{vEspnowGetOldPeers}}
\begin{table}[H]
\caption{Descripción de la función \emph{vEspnowGetOldPeers} }\label{vEspnowGetOldPeers}
\centering
\begin{tabular}{|c|c|}
\hline
Nombre  & vEspnowGetOldPeers \\
\hline
Descripción & Registrar los nodos al iniciar\\
\hline
Parámetros &  Vacío\\
\hline
Resultado & Serial, Reenvío o configuración \\
\hline
\end{tabular}
\end{table}

Junto con la función \emph{RegisterPeer} registra MAC de los nodos al energizar el nodo. Pues el registro se hace en la memoria volátil.
\subsubsection{Función \emph{espnow\_data\_prepare}}\label{prepare}
\begin{table}[H]
\caption{Descripción de la función \emph{espnow\_data\_prepare } }\label{espnowprepare }
\centering
\begin{tabular}{|c|c|}
\hline
Nombre  & espnow\_data\_prepare \\
\hline
Descripción & Preparar los datos a enviar\\
\hline
Parámetros &  variable \emph{send\_param}\\
\hline
Resultado & cargar datos de trama \emph{espnow}\\
\hline
\end{tabular}
\end{table}

Esta función prepara los trama inalámbrica, que contiene el chequeo de error, el identificador de nodo, si es unicast o broadcast, la dirección, etc. 
\subsubsection{Función \emph{espnow\_data\_parse}}
\begin{table}[H]
\caption{Descripción de la función \emph{espnow\_data\_parse} }\label{espnowparse }
\centering
\begin{tabular}{|c|c|}
\hline
Nombre  & espnow\_data\_parse \\
\hline
Descripción & Descompone los datos recibidos\\
\hline
Parámetros &  datos, longitud de datos, estado\\
\hline
Resultado & cargar datos de trama \emph{esp\_now} \\
\hline
\end{tabular}
\end{table}

Cumple la función complementaría a la función \ref{prepare}, descompone los datos recibidos, comprueba el chequeo de error, etc. Se usa en la máquina de estado de recepción inalámbrica.
\subsection{ Circuito de un nodo para una red WiFi mallada basada en el microcontrolador ESP32.}

El desarrollo del software de la red ser realizó de forma iterativa sobre las tarjetas de desarrollo, por lo que la red fue implementada mientras era desarrollada. 

Se consideran las  especificaciones del diseño en la sección \ref{hardware} y las recomendaciones técnicas realizadas por \textit{Espressif} \cite{testAntena} para el diseño de PCB con el ESP32.  

\subsubsection{Posicionamiento del ESP32 en el PCB}
El encapsulado  ESP-WROOM-32 está diseñada para ser soldado en una PCB huésped. El ESP-WROOM-32 usa una antena de F invertida (MIFA),  para la banda de WiFi 2,4 GHz,  con un ganancia de 20dBi. La figura \ref{Fig  1: Antenna Placement} muestra las seis opciones de colocación que son comúnmente usadas (la opción uno es usada como referencia). Los resultados de las pruebas ejecutadas por \emph{Espressif} muestran que las opciones 2 y 3 tienen los mejores rendimientos, mientras el de las otras son sub-óptimos \cite{testAntena}.

\begin{figure}[H]
\centering
\includegraphics[scale=0.7]{opcionesPCB.png}
\captionsource{Opciones para colocación en PCB}{Adaptada de \cite{testAntena}}\label{Fig  1: Antenna Placement}
\end{figure}

Los resultados del estudio de basan en las mediciones de potencia WiFi y parámetros EVM (magnitud del vector de error)para varios canales para verificar el rendimiento del la antenas en diferentes posiciones. Los resultados fueron los siguientes:
\begin{enumerate}
\item Las opciones de colocación 1,2 y 3 básicamente no se muestran afectadas en el rendimiento de la antena siempre y cuando esta este enfrente de espacio abierto. Es recomendado proveer una espacio de al menos 5 mm alrededor de antena en cada dirección.

\item Si el PCB de la antes tiene que ser colocado en una tarjeta huésped, es recomendada la opción 4, que no posee plano de cobre bajo la antena, así hayan algunas pérdidas del rendimiento.

\item La opción 6 posee el peor rendimiento tanto en la transmisión como la recepción, pues se ve afectado por por la tarjeta huésped.
\end{enumerate}

Se eligió la opción 4, debido a que permite que la antena posea un soporte adicional sobre la PCB, considerando que no se coloca plano de tierra en ninguna capa. 

\subsubsection{El chip MAX-485}

\emph{Espressif} provee una ejemplo de conexión para el uso del chip MAX-3485, en cual se indica la topología para usar el UART como interfaz.  Se agrega, sin embargo, una resistencia de  \emph{pull-up} en el terminal asociado a TDX para evitar niveles indeterminados en dicho pin, causados por el estado en alta impedancia durante recepción. 


\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{maxim.png}
\caption{Ejemplo de conexión entre MAX-485 y UART}{Adaptada de \cite{imRS}}\label{Fig  2: MAX y UART}
\end{figure}

\subsubsection{Alimentación}%xxx agregar foto
Como se mencionó anteriormente, se usó la fuente LM2596S debido que se ajusta a las especificaciones del diseño.  Sin embargo, la tarjeta posee un tamaño comparable al del nodo, lo que fue determinante en la arquitectura del PCB.

\subsubsection{Estructura del  Circuito Impreso}

Se considera una capa con elementos de superficie (resistencia y condensadores). La fuente se adapta a través de pin \textit{headers} en la parte posterior de la capa. Se agregan los bloques terminales para el acceso de la alimentación externa y el bus RS-485.  Así mismo, se agregaron 3 pin \textit{headers} para el acceso al UART 0 y dos pares de pin header adicionales para el accionamiento de las funciones de \emph{BOOT} y \emph{EN}, en el ingreso al modo de programación del microcontrolador. El detalle del esquemático de observa en la figura \ref{esquematico}.

Los terminales se agregaron en la parte posterior de la capa del microcontrolador para evitar obstruir el espacio libre de la antena WiFi. observe las figuras \ref{pcbB} y \ref{pcbF}. 

Adicionalemente, se agregó un LED (GPIO 19)con el propósito de que sirva como testigo de comunicación en el encendido y durante la instalación. La tabla \ref{BOM} refleja la lista de materiales empleados  y sus características. 
\begin{table}[H]
\caption{Lista de materiales del circuito}\label{BOM}
\centering
\begin{tabular}{|c|c|c|}
\hline
Nombre  & Descripción & Encapsulado  \\
\hline
D2 & Diodo  emisor de luz enviar& 1206  \\
\hline
R1 &  Resistencia 10k $\Omega$  & 1206 \\
\hline
R2 &  Resistencia 10k $\Omega$  & 1206 \\
\hline
R3 &  Resistencia 1k $\Omega$ & 01 x 03 de 2,54 mm \\
\hline
R5 &  Resistencia 10k $\Omega$ & 1206 \\
\hline
C2 &  Condensador no polarizado, 100 uF  & 1206 \\
\hline
C4 &  Condensador no polarizado, 0,1 uF  & 1206 \\
\hline
J1 &  Pin header & 01 x 03 de 2,54 mm \\
\hline
J2 &  Bloque terminal & 01 x 04 de 5.00 mm ,Altech AK300  \\
\hline
J4 &  Pin header & 01 x 02 de 2,54 mm \\
\hline
J5 &  Pin header & 01 x 02 de 2,54 mm \\
\hline
U1 & Microcontrolador &ESP32-WROOM-32 \\
\hline
U2 & Covertidor RS-485 TTL (MAX485E)& SOIC-8 \\
\hline
DCDC1 & Convertidor DC-DC LM2596 & 43,00 mm x 20.80 mm \\
\hline
\end{tabular}
\end{table}
\begin{figure}[H]
\centering
\includegraphics[scale=1]{esquematico.eps}
\caption{Esquemático del nodo}\label{esquematico}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=1]{pcbF.eps}
\caption{Diagrama de circuito impreso capa superior}\label{pcbF}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=1]{pcbB.eps}
\caption{Diagrama de circuito impreso capa inferior}\label{pcbB}
\end{figure}


\subsection{Implementación  la red mallada diseñada}\label{implementacion}
La red mallada se implementó usando como nodos tarjetas de desarrollo junto con tarjetas para conversión RS-485 a TTL basadas en chip MAX-3485. Cada tarjeta se programó y configuró de acuerdo a la tabla \ref{Configuracion}. Se usaron un total de cuatro nodos con la topología de la figura \ref{topo} como base.  En el bus RS-485 del maestro se conectó un maestro Modbus proveniente de un computador a través de un convertido USB a RS-485 para generar las tramas. 
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
\hline
Nodo &  Descripción & Tasa de baudios serial\\
\hline
150 & Maestro conectado & Variable\\
\hline
151 &  Esclavos conectados  & 9600\\
\hline
152 & Modo de salto & No aplica\\
\hline
153 & Esclavos conectados & 9600\\
\hline
\end{tabular}
\caption{Configuración de los esclavos para la implementación}\label{Configuracion}
\end{table}

\begin{figure}[H]
\centering
\includegraphics[scale=0.7]{topo.eps}
\caption{Topología de implementación}\label{topo}
\end{figure}
Por otro lado, en el bus serial de los esclavos se conectaron unas unidades terminales remotas con capacidad de comunicación Modbus. En este caso se conectaron solo una remota por nodo. 

Las características de los equipos Modbus usados fueron los descritos en la tabla (Falta agregar). Adicionalmente la lista de materiales usada para la implementación de la red usando la tarjeta de desarrollo se presenta en la tabla \ref{BOM 2}.

\begin{table}[H]
\caption{Lista de materiales del circuito de implementación}\label{BOM 2}
\begin{tabular}{|c|c|c|}
\hline
Nombre  & Descripción & Detalle  \\
\hline
D2 & Diodo  emisor de luz enviar& TH 5mm \\
\hline
R3 &  Resistencia 1k $\Omega$ & TH \\
\hline
U1 & Tarjeta de desarrollo & ESP32-DevKit-V1 \\
\hline
U2 & Covertidor RS-485 TTL (MAX485E)& SOIC-8 \\
\hline
Alimentación & Cable USB  y AC/DC 120VAC/5VDC& -\\
\hline
Cables  & cables protoboard  &  Cantidad 14, macho-macho\\
\hline
Protoboard  & cables protoboard  & Elego \\
\hline
\end{tabular}
\end{table}
\subsubsection{Ilustración de los nodos}

 A continuación se presentan imágenes (figuras \ref{master Node} y \ref{Slave Node}) de los nodos donde se implementó la red.
 
 \begin{figure}[H]
 \centering
 \includegraphics[scale=0.115]{images/foto111.png}
 \caption{Hardware del nodo maestro.}\label{master Node}
 \end{figure}
 
\begin{figure}[H]
\centering
\includegraphics[scale=0.25]{images/foto2.jpeg}
\caption{Hardware de un nodo con un esclavo Modbus.}\label{Slave Node}
\end{figure}
\subsection{Análisis el rendimiento de la red de acuerdo a variaciones en los parámetros de transmisión de datos}

Las características principales de funcionamiento de la red Modbus son: distancia entre nodos, topología, tasa de baudios  serial, velocidad de muestreo, número de variables Modbus y topología. Para la evaluación del rendimiento se varió un parámetro respecto a a la vez. Así se observa la degradación de la calidad de servicio sin caer en numerosas pruebas redundantes. Las variaciones toman los valores expresados en la tabla \ref{parametros}.

\begin{table}[H]
\caption{Variación de parámetros en la pruebas de rendiemietno}\label{parametros}
\centering
\begin{tabular}{|c|c|c|}
\hline
Tasa serial [Baudios]&  Número de variables& velocidad de muestreo [s]\\
\hline
2400& 50 & 10,0 \\
\hline
4800 &  10 & 5,0 \\
\hline
9600 & 150 & 2,0 \\
\hline
19200 & 200 & 1,0 \\
\hline
38400 & 250 & -\\
\hline
\end{tabular}
\end{table}

Se estimará el error en función de la cantidad de excepciones Modbus que se obtengan en el maestro por cada esclavo, considerando la ecuación \ref{Ecuacion1}.
\begin{equation}
error = \dfrac{ cantidad \; de\; excepciones}{cantidad \;de \;solicitudes}  \cdot 100 \%\label{Ecuacion1}
\end{equation}

Se toma la topología de la figura \ref{topo} como base para todas las pruebas, excepto, por supuesto, la prueba de variación de topología.  Se colocó el nodo 150 como el nodo que posee el maestro conectado,  el nodo 151 para ejecutar  reenvío de datos y los nodo 153 y 152 con  un esclavo Modbus conectados.

Se conectaron los nodos con los nodos inalámbricos a una distancia menor a 10 cm. Se colocó el nodo 150 en la habitación del primer piso de una casa de paredes de concreto, el nodo 153 en otra habitación en la planta baja a una distancia recta del nodo maestro de aproximadamente 15 m, sin linea de vista. El  nodo 152 se dispuso en el primer piso a aproximadamente 8 m, con dos paredes intermedias. Y el nodo 151 en la misma habitación del maestro. 

Los nodos se colocaron con el plano de la antena perpendicular a la horizontal, sin una rotación específica. Las demás topologías de prueba descritas más adelante, se llevaron a cabo con esta misma disposición física.

Para las variaciones en la tasa de baudios, estás se cambiaron en todas las interfaces seriales, es decir, todas los buses posee la mima velocidad. 

En la tabla \ref{Condiciones} se presentan las condiciones bajo las cuales se hicieron cada una de las pruebas.

\begin{table}[H]
\caption{Condiciones para las pruebas de rendimiento, la prueba cuatro se asocia a la variación de las topologías.}\label{Condiciones}
\centering
\begin{tabular}{|c|c|c|c|}
\hline 
Prueba & Baudarate [Baudios] & Variables[n] & Tiempo de muestreo[s] \\ 
\hline 
1 & 9600 & 50 & Variable \\ 
\hline 
2 & 9600 & Variable & 5 \\ 
\hline 
3 & Variable & 50 & 5 \\ 
\hline 
4 & 9600 & 50 & 5 \\ 
\hline 
\end{tabular} 
\end{table}

